Dark Forest Noir + Client Backend Bundle
Generated: 2026-01-13
Includes: packages/contracts/**/*.nr, apps/client/src/Backend/**, resolve_arrival-related files (non-reference, non-tasks)
Excludes: packages/nft/**, reference/**, tasks/**

===== FILE: packages/contracts/src/feature_flags.nr =====
Explanation: Auto-generated feature flag globals (toggles admin-only actions for the contracts).
// Generated by scripts/set_feature_flags.js. Do not edit by hand.

pub global ADMIN_ACTIONS_ENABLED: bool = false;

===== FILE: packages/contracts/src/main.nr =====
Explanation: Core Dark Forest Noir contract with constants, storage, private validation, and public apply logic for gameplay actions.
mod mimc;
mod perlin;
mod feature_flags;
mod test;
mod types;
mod utils;

use dep::aztec::macros::aztec;

#[aztec]
pub contract DarkForest {
    use dep::aztec::{
        macros::{
            functions::{external, initializer, internal, only_self},
            storage::storage,
        },
        protocol_types::{
            address::AztecAddress,
            traits::{Deserialize, ToField},
        },
        state_vars::{Map, PublicMutable},
    };
    use dep::darkforest_nft::NFT;
    use dep::std::field::bn254;
    use crate::{
        feature_flags::ADMIN_ACTIONS_ENABLED,
        mimc::mimc_sponge_2_220,
        perlin::multi_scale_perlin,
        types::{
            Artifact,
            Arrival,
            GameConfig,
            Planet,
            PlanetArrivals,
            PlanetArtifacts,
            PlanetArtifactState,
            Player,
            RevealedCoords,
            Upgrade,
        },
        utils::{
            config_hash,
            exp_neg_q32,
            field_abs_u128,
            field_to_signed,
            pow2_frac_q32,
            signed_sub,
        },
    };

    global MAX_COORD_ABS: u128 = 2147483648;
    global MAX_ARRIVALS_PER_BUCKET: u8 = 6;
    global MAX_PLANET_ARTIFACTS: u8 = 5;
    global MOVE_KNOWN_FLAG: u64 = 0x8000000000000000;
    global ARRIVAL_TYPE_NORMAL: u8 = 1;
    global ARRIVAL_TYPE_PHOTOID: u8 = 2;
    global ARRIVAL_TYPE_WORMHOLE: u8 = 3;

    // Block-based cooldowns for artifact activation (v0.6 hours mapped to blocks).
    global ARTIFACT_COOLDOWN_BLOCKS: [u32; 10] = [24, 0, 0, 0, 0, 4, 4, 24, 24, 24];
    global PHOTOID_ACTIVATION_DELAY_BLOCKS: u32 = 4;
    global WORMHOLE_SPEED_MODIFIERS: [u64; 6] = [1, 2, 4, 8, 16, 32];

    global HOME_PLANET_POPULATION: u64 = 200000;
    global SPACE_JUNK_LIMIT: u64 = 1000;
    global PLANET_LEVEL_JUNK: [u64; 10] = [20, 25, 30, 35, 40, 45, 50, 55, 60, 65];
    global ABANDON_SPEED_CHANGE_PERCENT: u64 = 150;
    global ABANDON_RANGE_CHANGE_PERCENT: u64 = 150;
    global SHIP_ID_SALT: u64 = 1000;

    global PLANET_TYPE_PLANET: u8 = 0;
    global PLANET_TYPE_SILVER_MINE: u8 = 1;
    global PLANET_TYPE_FOUNDRY: u8 = 2;
    global PLANET_TYPE_TRADING_POST: u8 = 3;
    global PLANET_TYPE_SILVER_BANK: u8 = 4;

    global ARTIFACT_TYPE_MONOLITH: u8 = 1;
    global ARTIFACT_TYPE_COLOSSUS: u8 = 2;
    global ARTIFACT_TYPE_SPACESHIP: u8 = 3;
    global ARTIFACT_TYPE_PYRAMID: u8 = 4;
    global ARTIFACT_TYPE_WORMHOLE: u8 = 5;
    global ARTIFACT_TYPE_PLANETARY_SHIELD: u8 = 6;
    global ARTIFACT_TYPE_PHOTOID_CANNON: u8 = 7;
    global ARTIFACT_TYPE_BLOOM_FILTER: u8 = 8;
    global ARTIFACT_TYPE_BLACK_DOMAIN: u8 = 9;
    global ARTIFACT_TYPE_SHIP_MOTHERSHIP: u8 = 10;
    global ARTIFACT_TYPE_SHIP_CRESCENT: u8 = 11;
    global ARTIFACT_TYPE_SHIP_WHALE: u8 = 12;
    global ARTIFACT_TYPE_SHIP_GEAR: u8 = 13;
    global ARTIFACT_TYPE_SHIP_TITAN: u8 = 14;

    global ARTIFACT_RARITY_UNKNOWN: u8 = 0;
    global ARTIFACT_RARITY_COMMON: u8 = 1;
    global ARTIFACT_RARITY_RARE: u8 = 2;
    global ARTIFACT_RARITY_EPIC: u8 = 3;
    global ARTIFACT_RARITY_LEGENDARY: u8 = 4;
    global ARTIFACT_RARITY_MYTHIC: u8 = 5;

    global BIOME_UNKNOWN: u8 = 0;
    global BIOME_OCEAN: u8 = 1;
    global BIOME_FOREST: u8 = 2;
    global BIOME_GRASSLAND: u8 = 3;
    global BIOME_TUNDRA: u8 = 4;
    global BIOME_SWAMP: u8 = 5;
    global BIOME_DESERT: u8 = 6;
    global BIOME_ICE: u8 = 7;
    global BIOME_WASTELAND: u8 = 8;
    global BIOME_LAVA: u8 = 9;
    global BIOME_CORRUPTED: u8 = 10;

    global UPGRADE_BRANCH_DEFENSE: u8 = 0;
    global UPGRADE_BRANCH_RANGE: u8 = 1;
    global UPGRADE_BRANCH_SPEED: u8 = 2;

    global UPGRADE_POP_CAP_MULTIPLIER: [u64; 3] = [120, 120, 120];
    global UPGRADE_POP_GROWTH_MULTIPLIER: [u64; 3] = [120, 120, 120];
    global UPGRADE_RANGE_MULTIPLIER: [u64; 3] = [100, 125, 100];
    global UPGRADE_SPEED_MULTIPLIER: [u64; 3] = [100, 100, 175];
    global UPGRADE_DEFENSE_MULTIPLIER: [u64; 3] = [120, 100, 100];

    global SPACE_TYPE_NEBULA: u8 = 0;
    global SPACE_TYPE_SPACE: u8 = 1;
    global SPACE_TYPE_DEEP_SPACE: u8 = 2;
    global SPACE_TYPE_DEAD_SPACE: u8 = 3;

    global PLANET_DEFAULT_POP_CAP: [u64; 10] = [
        100000,
        400000,
        1600000,
        6000000,
        25000000,
        100000000,
        300000000,
        500000000,
        700000000,
        800000000,
    ];
    global PLANET_DEFAULT_POP_GROWTH: [u64; 10] = [
        417,
        833,
        1250,
        1667,
        2083,
        2500,
        2917,
        3333,
        3750,
        4167,
    ];
    global PLANET_DEFAULT_RANGE: [u64; 10] = [
        99,
        177,
        315,
        591,
        1025,
        1734,
        2838,
        4414,
        6306,
        8829,
    ];
    global PLANET_DEFAULT_SPEED: [u64; 10] = [75, 75, 75, 75, 75, 75, 75, 75, 75, 75];
    global PLANET_DEFAULT_DEFENSE: [u64; 10] = [
        400,
        400,
        300,
        300,
        300,
        200,
        200,
        200,
        200,
        200,
    ];
    global PLANET_DEFAULT_SILVER_GROWTH: [u64; 10] = [
        0,
        56,
        167,
        417,
        833,
        1667,
        2778,
        2778,
        2778,
        2778,
    ];
    global PLANET_DEFAULT_SILVER_CAP: [u64; 10] = [
        0,
        100000,
        500000,
        2500000,
        12000000,
        50000000,
        100000000,
        200000000,
        300000000,
        400000000,
    ];
    global PLANET_DEFAULT_BARBARIAN_PERCENT: [u64; 10] = [
        0,
        1,
        2,
        3,
        4,
        5,
        7,
        10,
        20,
        25,
    ];
    global PERLIN_THRESHOLD_1: u64 = 14;
    global PERLIN_THRESHOLD_2: u64 = 15;
    global PERLIN_THRESHOLD_3: u64 = 19;
    global BIOME_THRESHOLD_1: u64 = 15;
    global BIOME_THRESHOLD_2: u64 = 17;
    global MAX_NATURAL_PLANET_LEVEL: u8 = 9;
    global PLANET_LEVEL_THRESHOLDS: [u64; 10] = [
        16777216,
        4194292,
        1048561,
        262128,
        65520,
        16368,
        4080,
        1008,
        240,
        48,
    ];
    global PLANET_TYPE_WEIGHTS: [[[u64; 5]; 10]; 4] = [
        [
            [1, 0, 0, 0, 0],
            [13, 2, 0, 1, 0],
            [13, 2, 0, 1, 0],
            [13, 2, 0, 0, 1],
            [13, 2, 0, 0, 1],
            [13, 2, 0, 0, 1],
            [13, 2, 0, 0, 1],
            [13, 2, 0, 0, 1],
            [13, 2, 0, 0, 1],
            [13, 2, 0, 0, 1],
        ],
        [
            [1, 0, 0, 0, 0],
            [13, 2, 1, 0, 0],
            [12, 2, 1, 1, 0],
            [11, 2, 1, 1, 1],
            [12, 2, 1, 0, 1],
            [12, 2, 1, 0, 1],
            [12, 2, 1, 0, 1],
            [12, 2, 1, 0, 1],

            [12, 2, 1, 0, 1],
            [12, 2, 1, 0, 1],
        ],
        [
            [1, 0, 0, 0, 0],
            [10, 4, 2, 0, 0],
            [10, 4, 1, 1, 0],
            [8, 4, 1, 2, 1],
            [8, 4, 1, 2, 1],
            [8, 4, 1, 2, 1],
            [8, 4, 1, 2, 1],
            [8, 4, 1, 2, 1],
            [8, 4, 1, 2, 1],
            [8, 4, 1, 2, 1],
        ],
        [
            [1, 0, 0, 0, 0],
            [11, 4, 1, 0, 0],
            [11, 4, 1, 0, 0],
            [7, 4, 2, 2, 1],
            [7, 4, 2, 2, 1],
            [7, 4, 2, 2, 1],
            [7, 4, 2, 2, 1],
            [7, 4, 2, 2, 1],
            [7, 4, 2, 2, 1],
            [7, 4, 2, 2, 1],
        ],
    ];

    #[storage]
    struct Storage<Context> {
        admin: PublicMutable<AztecAddress, Context>,
        nft_contract: PublicMutable<AztecAddress, Context>,
        config: PublicMutable<GameConfig, Context>,
        config_hash_spacetype: PublicMutable<Field, Context>,
        config_hash_biome: PublicMutable<Field, Context>,
        players: Map<AztecAddress, PublicMutable<Player, Context>, Context>,
        player_claimed_ships: Map<AztecAddress, PublicMutable<u8, Context>, Context>,
        player_space_junk: Map<AztecAddress, PublicMutable<u64, Context>, Context>,
        player_space_junk_limit: Map<AztecAddress, PublicMutable<u64, Context>, Context>,
        planets: Map<Field, PublicMutable<Planet, Context>, Context>,
        planet_destroyed: Map<Field, PublicMutable<u8, Context>, Context>,
        planet_space_junk: Map<Field, PublicMutable<u64, Context>, Context>,
        planet_energy_gro_doublers: Map<Field, PublicMutable<u8, Context>, Context>,
        planet_silver_gro_doublers: Map<Field, PublicMutable<u8, Context>, Context>,
        planet_pausers: Map<Field, PublicMutable<u8, Context>, Context>,
        planet_artifact_state: Map<Field, PublicMutable<PlanetArtifactState, Context>, Context>,
        artifacts: Map<Field, PublicMutable<Artifact, Context>, Context>,
        // Spaceships live in dedicated maps; artifact entries are materialized on demand.
        spaceships: Map<Field, PublicMutable<u8, Context>, Context>,
        spaceship_owners: Map<Field, PublicMutable<AztecAddress, Context>, Context>,
        planet_artifacts: Map<Field, PublicMutable<PlanetArtifacts, Context>, Context>,
        artifact_locations: Map<Field, PublicMutable<Field, Context>, Context>,
        arrivals: Map<Field, PublicMutable<Arrival, Context>, Context>,
        planet_arrivals: Map<Field, PublicMutable<PlanetArrivals, Context>, Context>,
        next_arrival_id: PublicMutable<u64, Context>,
        revealed: Map<Field, PublicMutable<RevealedCoords, Context>, Context>,
        touched_planet_ids_count: PublicMutable<u64, Context>,
        touched_planet_ids: Map<Field, PublicMutable<Field, Context>, Context>,
        touched_planet_seen: Map<Field, PublicMutable<u8, Context>, Context>,
        revealed_coords_count: PublicMutable<u64, Context>,
        revealed_coords: Map<Field, PublicMutable<RevealedCoords, Context>, Context>,
        revealed_seen: Map<Field, PublicMutable<u8, Context>, Context>,
    }

    #[external("public")]
    #[initializer]
    fn constructor(
        admin: AztecAddress,
        config: GameConfig,
        nft_contract: AztecAddress,
    ) {
        self.storage.admin.write(admin);
        assert(!nft_contract.eq(AztecAddress::zero()));
        self.storage.nft_contract.write(nft_contract);
        self.storage.next_arrival_id.write(1);
        self.storage.touched_planet_ids_count.write(0);
        self.storage.revealed_coords_count.write(0);
        let spacetype_hash = config_hash(
            config.planethash_key,
            config.spacetype_key,
            config.perlin_length_scale,
            config.perlin_mirror_x,
            config.perlin_mirror_y,
        );
        let biome_hash = config_hash(
            config.planethash_key,
            config.biomebase_key,
            config.perlin_length_scale,
            config.perlin_mirror_x,
            config.perlin_mirror_y,
        );
        self.storage.config_hash_spacetype.write(spacetype_hash);
        self.storage.config_hash_biome.write(biome_hash);
        self.storage.config.write(config);
    }

    #[internal("public")]
    fn space_type_from_perlin(perlin: u64) -> u8 {
        if perlin >= PERLIN_THRESHOLD_3 {
            SPACE_TYPE_DEAD_SPACE
        } else if perlin >= PERLIN_THRESHOLD_2 {
            SPACE_TYPE_DEEP_SPACE
        } else if perlin >= PERLIN_THRESHOLD_1 {
            SPACE_TYPE_SPACE
        } else {
            SPACE_TYPE_NEBULA
        }
    }

    #[internal("public")]
    fn planet_level_from_location(
        loc_bytes: [u8; 32],
        space_type: u8,
    ) -> u8 {
        let mut level_uint: u64 = 0;
        level_uint += (loc_bytes[4] as u64) << 16;
        level_uint += (loc_bytes[5] as u64) << 8;
        level_uint += loc_bytes[6] as u64;

        let mut level: u8 = 0;
        let mut found = false;
        for i in 0..10 {
            let idx = 9 - i;
            let threshold = PLANET_LEVEL_THRESHOLDS[idx];
            if (!found) & (level_uint < threshold) {
                level = idx as u8;
                found = true;
            }
        }

        if (space_type == SPACE_TYPE_NEBULA) & (level > 4u8) {
            level = 4;
        }
        if (space_type == SPACE_TYPE_SPACE) & (level > 5u8) {
            level = 5;
        }
        if level > MAX_NATURAL_PLANET_LEVEL {
            level = MAX_NATURAL_PLANET_LEVEL;
        }

        level
    }

    #[internal("public")]
    fn planet_type_from_location(
        loc_bytes: [u8; 32],
        space_type: u8,
        level: u8,
    ) -> u8 {
        let weights = PLANET_TYPE_WEIGHTS[space_type as u32][level as u32];
        let mut weight_sum: u64 = 0;
        for i in 0..5 {
            weight_sum += weights[i];
        }

        let mut thresholds: [u64; 5] = [0; 5];
        let mut remaining = weight_sum;
        for i in 0..5 {
            remaining = remaining - weights[i];
            thresholds[i] = (remaining * 256) / weight_sum;
        }

        let type_byte = loc_bytes[8] as u64;
        let mut planet_type: u8 = 0;
        let mut found = false;
        for i in 0..5 {
            if (!found) & (type_byte >= thresholds[i]) {
                planet_type = i as u8;
                found = true;
            }
        }
        planet_type
    }

    #[internal("public")]
    fn biome_from_space_type(space_type: u8, biomebase: u64) -> u8 {
        if space_type == SPACE_TYPE_DEAD_SPACE {
            BIOME_CORRUPTED
        } else {
            let mut biome: u16 = (space_type as u16) * 3u16;
            if biomebase < BIOME_THRESHOLD_1 {
                biome += 1;
            } else if biomebase < BIOME_THRESHOLD_2 {
                biome += 2;
            } else {
                biome += 3;
            }
            biome as u8
        }
    }

    #[internal("public")]
    fn artifact_rarity_from_planet_level(level: u8) -> u8 {
        if level <= 1u8 {
            ARTIFACT_RARITY_COMMON
        } else if level <= 3u8 {
            ARTIFACT_RARITY_RARE
        } else if level <= 5u8 {
            ARTIFACT_RARITY_EPIC
        } else if level <= 7u8 {
            ARTIFACT_RARITY_LEGENDARY
        } else {
            ARTIFACT_RARITY_MYTHIC
        }
    }

    #[internal("public")]
    fn mod_255_from_bits(bits: [u1; 254], skip: u32) -> u8 {
        let mut rem: u16 = 0;
        for i in 0..254 {
            let idx = 253 - i;
            if idx >= skip {
                let mut bit_val: u16 = 0;
                if bits[idx] == 1 {
                    bit_val = 1;
                }
                rem = (rem * 2 + bit_val) % 255;
            }
        }
        rem as u8
    }

    #[internal("public")]
    fn random_artifact_type_and_level_bonus(seed: Field, biome: u8) -> (u8, u8) {
        let bits: [u1; 254] = seed.to_le_bits();
        let last_byte = self.internal.mod_255_from_bits(bits, 0);
        let mut seed_mod_256: u32 = 0;
        for i in 0..8 {
            if bits[i] == 1 {
                seed_mod_256 += 1u32 << i;
            }
        }
        let mut second_last = self.internal.mod_255_from_bits(bits, 8);
        if seed_mod_256 < (last_byte as u32) {
            second_last = if second_last == 0 { 254 } else { second_last - 1 };
        }

        let mut artifact_type = ARTIFACT_TYPE_PYRAMID;
        if last_byte < 39u8 {
            artifact_type = ARTIFACT_TYPE_MONOLITH;
        } else if last_byte < 78u8 {
            artifact_type = ARTIFACT_TYPE_COLOSSUS;
        } else if last_byte < 156u8 {
            artifact_type = ARTIFACT_TYPE_PYRAMID;
        } else if last_byte < 171u8 {
            artifact_type = ARTIFACT_TYPE_WORMHOLE;
        } else if last_byte < 186u8 {
            artifact_type = ARTIFACT_TYPE_PLANETARY_SHIELD;
        } else if last_byte < 201u8 {

            artifact_type = ARTIFACT_TYPE_PHOTOID_CANNON;
        } else if last_byte < 216u8 {
            artifact_type = ARTIFACT_TYPE_BLOOM_FILTER;
        } else if last_byte < 231u8 {
            artifact_type = ARTIFACT_TYPE_BLACK_DOMAIN;
        } else {
            if biome == BIOME_ICE {
                artifact_type = ARTIFACT_TYPE_PLANETARY_SHIELD;
            } else if biome == BIOME_LAVA {
                artifact_type = ARTIFACT_TYPE_PHOTOID_CANNON;
            } else if biome == BIOME_WASTELAND {
                artifact_type = ARTIFACT_TYPE_BLOOM_FILTER;
            } else if biome == BIOME_CORRUPTED {
                artifact_type = ARTIFACT_TYPE_BLACK_DOMAIN;
            } else {
                artifact_type = ARTIFACT_TYPE_WORMHOLE;
            }
            artifact_type = ARTIFACT_TYPE_PHOTOID_CANNON;
        }

        let mut bonus: u8 = 0;
        if second_last < 4u8 {
            bonus = 2;
        } else if second_last < 16u8 {
            bonus = 1;
        }

        (artifact_type, bonus)
    }

    #[internal("public")]
    fn pseudo_blockhash(block_number: u32, planethash_key: Field) -> Field {
        mimc_sponge_2_220(block_number as Field, 0, planethash_key)
    }

    #[internal("public")]
    fn artifact_seed(
        location_id: Field,
        contract_address: AztecAddress,
        block_hash: Field,
        planethash_key: Field,
    ) -> Field {
        let addr_field = contract_address.to_field();
        let seed1 = mimc_sponge_2_220(location_id, addr_field, planethash_key);
        mimc_sponge_2_220(seed1, block_hash, planethash_key)
    }

    #[internal("public")]
    fn is_spaceship(artifact_type: u8) -> bool {
        (artifact_type >= ARTIFACT_TYPE_SHIP_MOTHERSHIP)
            & (artifact_type <= ARTIFACT_TYPE_SHIP_TITAN)
    }

    #[internal("public")]
    fn load_artifact_or_ship(artifact_id: Field) -> pub Artifact {
        let artifact = self.storage.artifacts.at(artifact_id).read();
        if artifact.is_initialized {
            artifact
        } else {
            let ship_type = self.storage.spaceships.at(artifact_id).read();
            if ship_type != 0 {
                let ship_owner = self.storage.spaceship_owners.at(artifact_id).read();
                Artifact::new(
                    artifact_id,
                    0,
                    ARTIFACT_RARITY_UNKNOWN,
                    BIOME_UNKNOWN,
                    ship_owner,
                    ship_type,
                )
            } else {
                artifact
            }
        }
    }

    #[internal("public")]
    fn ship_artifact_id(
        location_id: Field,
        ship_type: u8,
        planethash_key: Field,
    ) -> pub Field {
        let salt = (SHIP_ID_SALT + (ship_type as u64)) as Field;
        let seed = mimc_sponge_2_220(location_id, salt, planethash_key);
        assert(seed != 0);
        seed
    }

    #[internal("public")]
    fn is_planet_destroyed(location_id: Field) -> bool {
        self.storage.planet_destroyed.at(location_id).read() != 0
    }

    #[internal("public")]
    fn is_artifact_active(artifact: Artifact) -> bool {
        artifact.last_deactivated < artifact.last_activated
    }

    #[internal("public")]
    fn get_active_artifact(location_id: Field) -> pub Artifact {
        let artifacts = self.storage.planet_artifacts.at(location_id).read();
        let mut active = Artifact::empty();
        let mut found = false;
        for i in 0..(MAX_PLANET_ARTIFACTS as u32) {
            let artifact_id = artifacts.ids[i];
            if (!found) & (artifact_id != 0) {
                let artifact = self.storage.artifacts.at(artifact_id).read();
                if artifact.is_initialized & self.internal.is_artifact_active(artifact) {
                    active = artifact;
                    found = true;
                }
            }
        }
        active
    }

    #[internal("public")]
    fn default_upgrade() -> pub Upgrade {
        Upgrade::new(100, 100, 100, 100, 100)
    }

    #[internal("public")]
    fn time_delay_upgrade(artifact: Artifact) -> pub Upgrade {
        let mut upgrade = self.internal.default_upgrade();
        if artifact.artifact_type == ARTIFACT_TYPE_PHOTOID_CANNON {
            let range: [u64; 6] = [100, 200, 200, 200, 200, 200];
            let speed: [u64; 6] = [100, 500, 1000, 1500, 2000, 2500];
            let idx = artifact.rarity as u32;
            upgrade = Upgrade::new(100, 100, range[idx], speed[idx], 100);
        }
        upgrade
    }

    #[internal("public")]
    fn upgrade_for_artifact(artifact: Artifact) -> pub Upgrade {
        let mut upgrade = self.internal.default_upgrade();
        if artifact.artifact_type == ARTIFACT_TYPE_PLANETARY_SHIELD {
            let def: [u64; 6] = [100, 150, 200, 300, 450, 650];
            let idx = artifact.rarity as u32;
            upgrade = Upgrade::new(100, 100, 20, 20, def[idx]);
        } else if artifact.artifact_type == ARTIFACT_TYPE_PHOTOID_CANNON {
            let def: [u64; 6] = [100, 50, 40, 30, 20, 10];
            let idx = artifact.rarity as u32;
            upgrade = Upgrade::new(100, 100, 100, 100, def[idx]);
        } else if artifact.artifact_type >= ARTIFACT_TYPE_WORMHOLE {
            upgrade = self.internal.default_upgrade();
        } else {
            let mut pop_cap: u64 = 100;
            let mut pop_gro: u64 = 100;
            let mut range: u64 = 100;
            let mut speed: u64 = 100;
            let mut defense: u64 = 100;

            if artifact.artifact_type == ARTIFACT_TYPE_MONOLITH {
                pop_cap += 5;
                pop_gro += 5;
            } else if artifact.artifact_type == ARTIFACT_TYPE_COLOSSUS {
                speed += 5;
            } else if artifact.artifact_type == ARTIFACT_TYPE_SPACESHIP {
                range += 5;
            } else if artifact.artifact_type == ARTIFACT_TYPE_PYRAMID {
                defense += 5;
            }

            if artifact.planet_biome == BIOME_OCEAN {
                speed += 5;
                defense += 5;
            } else if artifact.planet_biome == BIOME_FOREST {
                defense += 5;
                pop_cap += 5;
                pop_gro += 5;
            } else if artifact.planet_biome == BIOME_GRASSLAND {
                pop_cap += 5;
                pop_gro += 5;
                range += 5;
            } else if artifact.planet_biome == BIOME_TUNDRA {
                defense += 5;
                range += 5;
            } else if artifact.planet_biome == BIOME_SWAMP {
                speed += 5;
                range += 5;
            } else if artifact.planet_biome == BIOME_DESERT {
                speed += 10;
            } else if artifact.planet_biome == BIOME_ICE {
                range += 10;
            } else if artifact.planet_biome == BIOME_WASTELAND {
                defense += 10;
            } else if artifact.planet_biome == BIOME_LAVA {
                pop_cap += 10;
                pop_gro += 10;
            } else if artifact.planet_biome == BIOME_CORRUPTED {
                range += 5;
                speed += 5;
                pop_cap += 5;
                pop_gro += 5;
            }

            let scale = 1u64 + ((artifact.rarity as u64) / 2u64);
            let scale_minus = scale - 1u64;
            let pop_cap_scaled =
                (scale as u128) * (pop_cap as u128) - (scale_minus as u128) * 100u128;
            let pop_gro_scaled =
                (scale as u128) * (pop_gro as u128) - (scale_minus as u128) * 100u128;
            let range_scaled =
                (scale as u128) * (range as u128) - (scale_minus as u128) * 100u128;
            let speed_scaled =
                (scale as u128) * (speed as u128) - (scale_minus as u128) * 100u128;
            let defense_scaled =
                (scale as u128) * (defense as u128) - (scale_minus as u128) * 100u128;

            upgrade = Upgrade::new(
                pop_cap_scaled as u64,
                pop_gro_scaled as u64,
                range_scaled as u64,
                speed_scaled as u64,
                defense_scaled as u64,
            );
        }
        upgrade
    }

    #[internal("public")]
    fn buff_planet(planet: Planet, upgrade: Upgrade) -> pub Planet {
        let mut updated = planet;
        updated.population_cap =
            ((updated.population_cap as u128) * (upgrade.pop_cap_multiplier as u128) / 100u128) as u64;
        updated.population_growth =
            ((updated.population_growth as u128) * (upgrade.pop_gro_multiplier as u128) / 100u128) as u64;
        updated.range =
            ((updated.range as u128) * (upgrade.range_multiplier as u128) / 100u128) as u64;
        updated.speed =
            ((updated.speed as u128) * (upgrade.speed_multiplier as u128) / 100u128) as u64;
        updated.defense =
            ((updated.defense as u128) * (upgrade.def_multiplier as u128) / 100u128) as u64;
        updated
    }

    #[internal("public")]
    fn debuff_planet(planet: Planet, upgrade: Upgrade) -> pub Planet {
        let mut updated = planet;
        updated.population_cap =
            ((updated.population_cap as u128) * 100u128 / (upgrade.pop_cap_multiplier as u128)) as u64;
        updated.population_growth =
            ((updated.population_growth as u128) * 100u128 / (upgrade.pop_gro_multiplier as u128)) as u64;
        updated.range =
            ((updated.range as u128) * 100u128 / (upgrade.range_multiplier as u128)) as u64;
        updated.speed =
            ((updated.speed as u128) * 100u128 / (upgrade.speed_multiplier as u128)) as u64;
        updated.defense =
            ((updated.defense as u128) * 100u128 / (upgrade.def_multiplier as u128)) as u64;

        updated
    }

    #[internal("public")]
    fn planet_artifacts_contains(
        artifacts: PlanetArtifacts,
        artifact_id: Field,
    ) -> bool {
        let mut found = false;
        for i in 0..(MAX_PLANET_ARTIFACTS as u32) {
            if (!found) & (artifacts.ids[i] == artifact_id) {
                found = true;
            }
        }
        found
    }

    #[internal("public")]
    fn planet_artifacts_has_space(artifacts: PlanetArtifacts) -> bool {
        let mut has_space = false;
        for i in 0..(MAX_PLANET_ARTIFACTS as u32) {
            if artifacts.ids[i] == 0 {
                has_space = true;
            }
        }
        has_space
    }

    #[internal("public")]
    fn planet_has_arrivals(location_id: Field) -> bool {
        let arrival_list = self.storage.planet_arrivals.at(location_id).read();
        let mut has = false;
        for i in 0..12 {
            if arrival_list.get(i) != 0 {
                has = true;
            }
        }
        has
    }

    #[internal("public")]
    fn planet_default_space_junk(planet: Planet) -> u64 {
        if planet.is_home_planet {
            0
        } else {
            PLANET_LEVEL_JUNK[planet.planet_level as u32]
        }
    }

    #[internal("public")]
    fn init_planet_extras(location_id: Field, planet: Planet) {
        let mut space_junk = self.internal.planet_default_space_junk(planet);
        if self.internal.is_half_space_junk(location_id) {
            space_junk /= 2;
        }
        self.storage.planet_space_junk.at(location_id).write(space_junk);
    }

    #[internal("public")]
    fn is_half_space_junk(location_id: Field) -> bool {
        let loc_bytes: [u8; 32] = location_id.to_be_bytes();
        loc_bytes[14] < 16
    }

    #[internal("public")]
    fn abandoning_upgrade() -> pub Upgrade {
        Upgrade::new(
            100,
            100,
            ABANDON_RANGE_CHANGE_PERCENT,
            ABANDON_SPEED_CHANGE_PERCENT,
            100,
        )
    }

    #[internal("public")]
    fn apply_spaceship_arrive(
        artifact: Artifact,
        location_id: Field,
        planet: Planet,
    ) -> pub Planet {
        let mut updated = planet;
        if !updated.is_home_planet {
            if artifact.artifact_type == ARTIFACT_TYPE_SHIP_MOTHERSHIP {
                let mut doublers =
                    self.storage.planet_energy_gro_doublers.at(location_id).read();
                if doublers == 0 {
                    updated.population_growth *= 2;
                }
                doublers += 1;
                self.storage.planet_energy_gro_doublers.at(location_id).write(doublers);
            } else if artifact.artifact_type == ARTIFACT_TYPE_SHIP_WHALE {
                let mut doublers =
                    self.storage.planet_silver_gro_doublers.at(location_id).read();
                if doublers == 0 {
                    updated.silver_growth *= 2;
                }
                doublers += 1;
                self.storage.planet_silver_gro_doublers.at(location_id).write(doublers);
            } else if artifact.artifact_type == ARTIFACT_TYPE_SHIP_TITAN {
                let mut pausers = self.storage.planet_pausers.at(location_id).read();
                pausers += 1;
                self.storage.planet_pausers.at(location_id).write(pausers);
            }
        }
        updated
    }

    #[internal("public")]
    fn apply_spaceship_depart(
        artifact: Artifact,
        location_id: Field,
        planet: Planet,
        current_block: u32,
    ) -> pub Planet {
        let mut updated = planet;
        if !updated.is_home_planet {
            if artifact.artifact_type == ARTIFACT_TYPE_SHIP_MOTHERSHIP {
                let mut doublers =
                    self.storage.planet_energy_gro_doublers.at(location_id).read();
                if doublers == 1 {
                    doublers -= 1;
                    updated.population_growth /= 2;
                } else if doublers > 1 {
                    doublers -= 1;
                }
                self.storage.planet_energy_gro_doublers.at(location_id).write(doublers);
            } else if artifact.artifact_type == ARTIFACT_TYPE_SHIP_WHALE {
                let mut doublers =
                    self.storage.planet_silver_gro_doublers.at(location_id).read();
                if doublers == 1 {
                    doublers -= 1;
                    updated.silver_growth /= 2;
                } else if doublers > 1 {
                    doublers -= 1;
                }
                self.storage.planet_silver_gro_doublers.at(location_id).write(doublers);
            } else if artifact.artifact_type == ARTIFACT_TYPE_SHIP_TITAN {
                updated.last_updated = current_block;
                let mut pausers = self.storage.planet_pausers.at(location_id).read();
                if pausers > 0 {
                    pausers -= 1;
                }
                self.storage.planet_pausers.at(location_id).write(pausers);
            }
        }
        updated
    }

    #[internal("public")]
    fn planet_artifacts_add(
        artifacts: PlanetArtifacts,
        artifact_id: Field,
    ) -> pub PlanetArtifacts {
        let mut artifacts = artifacts;
        let mut inserted = false;
        for i in 0..(MAX_PLANET_ARTIFACTS as u32) {
            if (!inserted) & (artifacts.ids[i] == 0) {
                artifacts.ids[i] = artifact_id;
                inserted = true;
            }
        }
        assert(inserted);
        artifacts
    }

    #[internal("public")]
    fn planet_artifacts_remove(
        artifacts: PlanetArtifacts,
        artifact_id: Field,
    ) -> pub PlanetArtifacts {
        let mut artifacts = artifacts;
        let mut removed = false;
        for i in 0..(MAX_PLANET_ARTIFACTS as u32) {
            if artifacts.ids[i] == artifact_id {
                artifacts.ids[i] = 0;
                removed = true;
            }
        }
        assert(removed);
        artifacts
    }

    #[internal("public")]
    fn nft_mint(to: AztecAddress, token_id: Field) {
        let nft_addr = self.storage.nft_contract.read();
        let _ = NFT::at(nft_addr).mint(to, token_id).call(self.context);
    }

    #[internal("public")]
    fn nft_transfer(from: AztecAddress, to: AztecAddress, token_id: Field) {
        let nft_addr = self.storage.nft_contract.read();
        let _ = NFT::at(nft_addr)
            .transfer_in_public(from, to, token_id, 0)
            .call(self.context);
    }


    #[internal("public")]
    fn default_planet(
        owner: AztecAddress,
        location_id: Field,
        perlin: u64,
        is_home: bool,
        current_block: u32,
    ) -> pub Planet {
        let loc_bytes: [u8; 32] = location_id.to_be_bytes();
        let space_type = self.internal.space_type_from_perlin(perlin);
        let level = self.internal.planet_level_from_location(loc_bytes, space_type);
        let planet_type =
            self.internal.planet_type_from_location(loc_bytes, space_type, level);

        if is_home {
            assert(level == 0);
            assert(planet_type == PLANET_TYPE_PLANET);
        }

        self.internal.default_planet_from_stats(
            owner,
            location_id,
            perlin,
            level,
            planet_type,
            space_type,
            is_home,
            current_block,
        )
    }

    #[internal("public")]
    fn default_planet_from_stats(
        owner: AztecAddress,
        location_id: Field,
        perlin: u64,
        level: u8,
        planet_type: u8,
        space_type: u8,
        is_home: bool,
        current_block: u32,
    ) -> pub Planet {
        let loc_bytes: [u8; 32] = location_id.to_be_bytes();
        let level_idx = level as u32;
        let mut population_cap = PLANET_DEFAULT_POP_CAP[level_idx];
        let mut population_growth = PLANET_DEFAULT_POP_GROWTH[level_idx];
        let mut range = PLANET_DEFAULT_RANGE[level_idx];
        let mut speed = PLANET_DEFAULT_SPEED[level_idx];
        let mut defense = PLANET_DEFAULT_DEFENSE[level_idx];
        let mut silver_cap = PLANET_DEFAULT_SILVER_CAP[level_idx];
        let mut silver_growth = if planet_type == PLANET_TYPE_SILVER_MINE {
            PLANET_DEFAULT_SILVER_GROWTH[level_idx]

        } else {
            0
        };

        let pop_cap_boost = loc_bytes[9] < 16;
        let pop_gro_boost = loc_bytes[10] < 16;
        let range_boost = loc_bytes[11] < 16;
        let speed_boost = loc_bytes[12] < 16;
        let def_boost = loc_bytes[13] < 16;

        if pop_cap_boost {
            population_cap *= 2;
        }
        if pop_gro_boost {
            population_growth *= 2;
        }
        if range_boost {
            range *= 2;
        }
        if speed_boost {
            speed *= 2;
        }
        if def_boost {
            defense *= 2;
        }

        if space_type == SPACE_TYPE_DEAD_SPACE {
            range *= 2;
            speed *= 2;
            population_cap *= 2;
            population_growth *= 2;
            silver_cap *= 2;
            silver_growth *= 2;
            defense = (defense * 3) / 20;
        } else if space_type == SPACE_TYPE_DEEP_SPACE {
            range = (range * 3) / 2;
            speed = (speed * 3) / 2;
            population_cap = (population_cap * 3) / 2;
            population_growth = (population_growth * 3) / 2;
            silver_cap = (silver_cap * 3) / 2;
            silver_growth = (silver_growth * 3) / 2;
            defense = defense / 4;
        } else if space_type == SPACE_TYPE_SPACE {
            range = (range * 5) / 4;
            speed = (speed * 5) / 4;
            population_cap = (population_cap * 5) / 4;
            population_growth = (population_growth * 5) / 4;
            silver_cap = (silver_cap * 5) / 4;
            silver_growth = (silver_growth * 5) / 4;
            defense = defense / 2;
        }

        if planet_type == PLANET_TYPE_SILVER_MINE {
            silver_cap *= 2;
            defense /= 2;
        } else if planet_type == PLANET_TYPE_SILVER_BANK {
            speed /= 2;
            silver_cap *= 10;
            population_growth = 0;
            population_cap *= 5;
        } else if planet_type == PLANET_TYPE_TRADING_POST {
            defense /= 2;
            silver_cap *= 2;
        }

        let mut population =
            (population_cap * PLANET_DEFAULT_BARBARIAN_PERCENT[level_idx]) / 100;

        if space_type == SPACE_TYPE_DEAD_SPACE {
            population *= 20;
        } else if space_type == SPACE_TYPE_DEEP_SPACE {
            population *= 10;
        } else if space_type == SPACE_TYPE_SPACE {
            population *= 4;
        }
        if planet_type == PLANET_TYPE_SILVER_BANK {
            population /= 2;
        }

        let mut silver = 0;
        if planet_type == PLANET_TYPE_SILVER_MINE {
            silver = silver_cap / 2;
        }

        // Scale time-dependent rates by the on-chain time factor (hundredths).
        let time_factor = self.storage.config.read().time_factor_hundredths;
        population_growth = (population_growth * time_factor) / 100;
        silver_growth = (silver_growth * time_factor) / 100;

        let mut planet_owner = AztecAddress::zero();
        let mut is_home_planet = false;
        if is_home {
            planet_owner = owner;
            population = HOME_PLANET_POPULATION;
            silver = 0;
            is_home_planet = true;
        }

        Planet::new(
            planet_owner,
            perlin,
            population,
            population_cap,
            population_growth,
            silver,
            silver_cap,
            silver_growth,
            range,
            speed,
            defense,
            current_block,
            level,
            planet_type,
            space_type,
            is_home_planet,
            0,
            0,
            0,
        )
    }

    #[internal("public")]
    fn decayed_population(
        pop_moved: u64,
        dist: u64,
        range: u64,
        pop_cap: u64,
    ) -> pub u64 {
        let mut result = 0u64;
        if range != 0 {
            let x_fp = ((dist as u128) << 32) / (range as u128);
            let int_part = (x_fp >> 32) as u32;
            let frac_part = (x_fp & 0xFFFF_FFFF) as u32;

            let pow_frac = pow2_frac_q32(frac_part);
            let pop_scaled = (pop_moved as u128) << 32;
            let pop_after_frac = pop_scaled / pow_frac;
            let pop_after_int = if int_part >= 128 {
                0
            } else {
                pop_after_frac >> (int_part as u128)
            };

            let big_planet_debuff = (pop_cap / 20) as u128;
            result = if pop_after_int > big_planet_debuff {
                (pop_after_int - big_planet_debuff) as u64
            } else {
                0
            };
        }
        result
    }

    #[internal("public")]
    fn update_population(
        planet: Planet,
        time_elapsed: u128,
        pausers: u8,
    ) -> pub Planet {
        let mut updated = planet;
        if time_elapsed != 0 {
            let pop_cap = updated.population_cap as u128;
            let pop = updated.population as u128;
            let prev_pop = updated.population;
            if (pop != 0) & (pop_cap != 0) {
                let numerator =
                    (4u128 * (updated.population_growth as u128)) * time_elapsed;
                let x_q32 = (numerator << 32) / pop_cap;
                let exp_neg = exp_neg_q32(x_q32);

                if exp_neg == 0 {
                    updated.population = updated.population_cap;
                } else {
                    let ratio_q32 = (pop_cap << 32) / pop;
                    let mut ratio_minus_one_neg = false;
                    let mut ratio_minus_one_mag: u128 = 0;
                    if ratio_q32 >= (1u128 << 32) {
                        ratio_minus_one_mag = ratio_q32 - (1u128 << 32);
                    } else {
                        ratio_minus_one_mag = (1u128 << 32) - ratio_q32;
                        ratio_minus_one_neg = true;
                    }
                    let product_mag = (exp_neg * ratio_minus_one_mag) >> 32;
                    let denom_q32 = if ratio_minus_one_neg {
                        if product_mag >= (1u128 << 32) {
                            1u128
                        } else {
                            (1u128 << 32) - product_mag
                        }
                    } else {
                        (1u128 << 32) + product_mag
                    };
                    let new_pop = (pop_cap << 32) / denom_q32;
                    updated.population = new_pop as u64;
                }

                if (pausers > 0) & (updated.population > prev_pop) {
                    updated.population = prev_pop;
                }

                if (updated.planet_type == PLANET_TYPE_SILVER_BANK) | (pausers > 0)
                {
                    if updated.population > updated.population_cap {
                        updated.population = updated.population_cap;
                    }
                }
            }
        }
        updated
    }

    #[internal("public")]
    fn update_silver(planet: Planet, time_elapsed: u128) -> pub Planet {
        let mut updated = planet;
        if time_elapsed != 0 {
            let silver = updated.silver as u128;
            let silver_cap = updated.silver_cap as u128;
            if silver < silver_cap {
                let growth = updated.silver_growth as u128;
                let mined = growth * time_elapsed;
                let next_silver = silver + mined;
                updated.silver = if next_silver > silver_cap {
                    silver_cap as u64
                } else {
                    next_silver as u64
                };
            }
        }
        updated
    }

    #[internal("public")]
    fn process_pending_arrivals(location_id: Field, up_to_block: u32) {
        let mut done = false;
        for _ in 0..12 {
            if !done {
                let arrival_list = self.storage.planet_arrivals.at(location_id).read();
                let mut earliest_block: u32 = 0xFFFF_FFFF;
                let mut earliest_id: u64 = 0;
                for i in 0..12 {
                    let arrival_id = arrival_list.get(i);
                    if arrival_id != 0 {
                        let arrival = self.storage.arrivals.at(arrival_id as Field).read();
                        let arrival_block = arrival.arrival_block();
                        if (arrival_block != 0) & (arrival_block <= up_to_block) {
                            if arrival_block < earliest_block {
                                earliest_block = arrival_block;
                                earliest_id = arrival_id;
                            }
                        }
                    }
                }

                    }
                }

                if earliest_id == 0 {
                    done = true;
                } else {
                    self.internal.execute_arrival(earliest_id);
                }
            }
        }
    }

    #[internal("public")]
    fn refresh_planet(location_id: Field, planet: Planet, update_block: u32) -> pub Planet {
        let mut updated = planet;
        if updated.is_initialized & (update_block > updated.last_updated) {
            let time_elapsed = (update_block - updated.last_updated) as u128;
            if !updated.owner.eq(AztecAddress::zero()) {
                let pausers = self.storage.planet_pausers.at(location_id).read();
                updated = self.internal.update_population(updated, time_elapsed, pausers);
                if updated.planet_type == PLANET_TYPE_SILVER_MINE {
                    updated = self.internal.update_silver(updated, time_elapsed);
                }
            }
            updated.last_updated = update_block;
        }
        updated
    }

    #[internal("public")]
    fn index_touched_planet(location_id: Field) {
        let seen = self.storage.touched_planet_seen.at(location_id).read();
        if seen == 0 {
            let idx = self.storage.touched_planet_ids_count.read();
            self.storage.touched_planet_ids.at(idx as Field).write(location_id);
            self.storage.touched_planet_ids_count.write(idx + 1);
            self.storage.touched_planet_seen.at(location_id).write(1);
        }
    }

    #[internal("public")]
    fn index_revealed_coords(
        location_id: Field,
        x: Field,
        y: Field,
        revealer: AztecAddress,
    ) {
        let seen = self.storage.revealed_seen.at(location_id).read();
        if seen == 0 {
            let idx = self.storage.revealed_coords_count.read();
            let coords = RevealedCoords::new(location_id, x, y, revealer);
            self.storage.revealed_coords.at(idx as Field).write(coords);
            self.storage.revealed_coords_count.write(idx + 1);
            self.storage.revealed_seen.at(location_id).write(1);
        }
    }


    #[external("private")]
    fn init_player(
        x: Field,
        y: Field,
        radius: u64,
        planethash_key: Field,
        spacetype_key: Field,
        perlin_length_scale: u64,
        perlin_mirror_x: bool,
        perlin_mirror_y: bool,
        expected_config_hash: Field,
        max_location_id: Field,
        world_radius: u64,
        spawn_rim_area: u64,
        init_perlin_min: u64,
        init_perlin_max: u64,
    ) {
        let player = self.context.msg_sender().unwrap();

        let x_abs = field_abs_u128(x);
        let y_abs = field_abs_u128(y);
        assert(x_abs <= MAX_COORD_ABS);
        assert(y_abs <= MAX_COORD_ABS);

        let r_u = radius as u128;
        let dist_sq = x_abs * x_abs + y_abs * y_abs;
        let r_sq = r_u * r_u;
        assert(dist_sq < r_sq);

        let perlin_u64 = multi_scale_perlin(
            x,
            y,
            spacetype_key,
            perlin_length_scale,
            perlin_mirror_x,
            perlin_mirror_y,
        );
        let cfg_hash = config_hash(
            planethash_key,
            spacetype_key,
            perlin_length_scale,
            perlin_mirror_x,
            perlin_mirror_y,
        );

        let location_id = mimc_sponge_2_220(x, y, planethash_key);
        assert(cfg_hash == expected_config_hash);
        assert(bn254::lt(location_id, max_location_id));
        assert(radius <= world_radius);
        if spawn_rim_area != 0 {
            assert(dist_sq * 100 > r_sq * 98);
            let radius_u = radius as u128;
            let world_u = world_radius as u128;
            let lhs = ((radius_u * radius_u * 314u128) / 100u128)
                + (spawn_rim_area as u128);
            let rhs = (world_u * world_u * 314u128) / 100u128;
            assert(lhs >= rhs);
        }
        assert(
            (perlin_u64 >= init_perlin_min)
            & (perlin_u64 < init_perlin_max)
        );

        // Private nullifier ensures init claims are one-time even if public state is stale within a block.
        self.context.push_nullifier(location_id);
        let player_nullifier = mimc_sponge_2_220(player.to_field(), 1, planethash_key);
        self.context.push_nullifier(player_nullifier);

        self.enqueue(
            DarkForest::at(self.context.this_address()).apply_init_player(
                player,
                location_id,
                perlin_u64,
            )
        );
    }

    #[external("public")]
    #[only_self]
    fn apply_init_player(
        player: AztecAddress,
        location_id: Field,
        perlin: u64,
    ) {
        let current_block = self.context.block_number();
        let existing_planet = self.storage.planets.at(location_id).read();
        // v0.6: LibPlanet._initializePlanet reverts if the planet is already initialized.
        assert(!existing_planet.is_initialized);
        let planet = self.internal.default_planet(
            player,
            location_id,
            perlin,
            true,
            current_block
        );
        self.storage.planets.at(location_id).write(planet);
        self.internal.init_planet_extras(location_id, planet);
        self.storage
            .players
            .at(player)
            .write(Player::new(location_id, current_block));
        self.storage.player_claimed_ships.at(player).write(0);
        self.storage.player_space_junk.at(player).write(0);
        self.storage
            .player_space_junk_limit
            .at(player)
            .write(SPACE_JUNK_LIMIT);
        self.internal.index_touched_planet(location_id);
    }

    #[external("public")]
    #[only_self]
    fn apply_player_action(
        player: AztecAddress,
        location_id: Field,
        x: Field,
        y: Field,
        perlin: u64,
        radius: u64,
        config_hash: Field,
        action: u8,
    ) {
        let config = self.storage.config.read();
        let current_block = self.context.block_number();
        if action == 1 {
            let existing = self.storage.revealed.at(location_id).read();
            assert(existing.location_id == 0);

            let admin = self.storage.admin.read();
            if !player.eq(admin) {
                if config.location_reveal_cooldown > 0 {
                    let player_state = self.storage.players.at(player).read();
                    assert(
                        current_block - player_state.last_reveal_block
                            > config.location_reveal_cooldown
                    );
                }
            }

            let existing_planet = self.storage.planets.at(location_id).read();
            if !existing_planet.is_initialized {
                let planet = self.internal.default_planet(
                    AztecAddress::zero(),
                    location_id,
                    perlin,
                    false,
                    current_block
                );
                // Mark the location as initialized so future inits fail deterministically.
                self.context.push_nullifier(location_id);
                self.storage.planets.at(location_id).write(planet);
                self.internal.init_planet_extras(location_id, planet);
            }

            self.storage
                .revealed
                .at(location_id)
                .write(RevealedCoords::new(location_id, x, y, player));
            self.internal.index_touched_planet(location_id);
            self.internal.index_revealed_coords(location_id, x, y, player);

            let mut player_state = self.storage.players.at(player).read();
            player_state.last_reveal_block = current_block;
            self.storage.players.at(player).write(player_state);
        } else if action == 2 {
            let player_state = self.storage.players.at(player).read();
            assert(player_state.is_initialized);
            let claimed = self.storage.player_claimed_ships.at(player).read();
            assert(claimed == 0);
            assert(player_state.home_planet == location_id);

            let planet = self.storage.planets.at(location_id).read();
            assert(planet.owner.eq(player));

            let mut planet_artifacts = self.storage.planet_artifacts.at(location_id).read();

            let ship_types: [u8; 5] = [
                ARTIFACT_TYPE_SHIP_MOTHERSHIP,
                ARTIFACT_TYPE_SHIP_CRESCENT,
                ARTIFACT_TYPE_SHIP_WHALE,
                ARTIFACT_TYPE_SHIP_GEAR,
                ARTIFACT_TYPE_SHIP_TITAN,
            ];
            for i in 0..5 {
                let ship_type = ship_types[i];
                let ship_id =
                    self.internal.ship_artifact_id(location_id, ship_type, config.planethash_key);
                self.storage.spaceships.at(ship_id).write(ship_type);
                self.storage.spaceship_owners.at(ship_id).write(player);
                self.storage.artifact_locations.at(ship_id).write(location_id);
                self.internal.nft_mint(player, ship_id);
                planet_artifacts = self.internal.planet_artifacts_add(

                    planet_artifacts,
                    ship_id
                );
            }

            self.storage.planet_artifacts.at(location_id).write(planet_artifacts);
            self.storage.player_claimed_ships.at(player).write(1);
        } else if action == 3 {
            // For action 3, radius carries the upgrade branch from the private call.
            let branch = radius as u8;
            self.internal.execute_upgrade_planet(player, location_id, branch);
        } else if action == 4 {
            let planet = self.storage.planets.at(location_id).read();
            assert(!self.internal.is_planet_destroyed(location_id));
            assert(planet.owner.eq(player));
            assert(planet.planet_type == PLANET_TYPE_FOUNDRY);

            let mut state = self.storage.planet_artifact_state.at(location_id).read();
            assert(state.prospected_block_number == 0);
            state.prospected_block_number = current_block;
            self.storage.planet_artifact_state.at(location_id).write(state);
        } else if action == 5 {
            let stored = self.storage.config_hash_biome.read();
            assert(config_hash == stored);
            let biomebase = perlin;
            let planet = self.storage.planets.at(location_id).read();
            assert(!self.internal.is_planet_destroyed(location_id));
            assert(planet.owner.eq(player));
            assert(planet.planet_type == PLANET_TYPE_FOUNDRY);

            let mut state = self.storage.planet_artifact_state.at(location_id).read();
            assert(!state.has_tried_finding_artifact);
            assert(state.prospected_block_number != 0);

            assert(current_block > state.prospected_block_number);
            let blocks_since = current_block - state.prospected_block_number;
            assert(blocks_since < 256);

            let biome = self.internal.biome_from_space_type(planet.space_type, biomebase);
            let block_hash = self.internal.pseudo_blockhash(
                state.prospected_block_number,
                config.planethash_key,
            );
            let artifact_seed = self.internal.artifact_seed(
                location_id,
                self.context.this_address(),
                block_hash,
                config.planethash_key,
            );
            assert(artifact_seed != 0);
            let (artifact_type, level_bonus) =
                self.internal.random_artifact_type_and_level_bonus(artifact_seed, biome);
            let level_with_bonus =
                (planet.planet_level as u16 + level_bonus as u16) as u8;
            let rarity = self.internal.artifact_rarity_from_planet_level(level_with_bonus);

            let existing_artifact = self.storage.artifacts.at(artifact_seed).read();
            assert(!existing_artifact.is_initialized);
            let mut planet_artifacts = self.storage.planet_artifacts.at(location_id).read();
            planet_artifacts =
                self.internal.planet_artifacts_add(planet_artifacts, artifact_seed);

            let artifact = Artifact::new(
                artifact_seed,
                location_id,
                rarity,
                biome,
                player,
                artifact_type,
            );
            self.storage.artifacts.at(artifact_seed).write(artifact);
            self.storage.planet_artifacts.at(location_id).write(planet_artifacts);
            self.storage.artifact_locations.at(artifact_seed).write(location_id);
            let contract_addr = self.context.this_address();
            self.internal.nft_mint(contract_addr, artifact_seed);

            state.has_tried_finding_artifact = true;
            self.storage.planet_artifact_state.at(location_id).write(state);
        } else if (action == 10) | (action == 11) {
            let withdrawing = action == 11;
            let artifact_id = x;

            let planet = self.storage.planets.at(location_id).read();
            assert(!self.internal.is_planet_destroyed(location_id));
            assert(planet.owner.eq(player));
            assert(planet.planet_type == PLANET_TYPE_TRADING_POST);

            let artifact = self.storage.artifacts.at(artifact_id).read();
            assert(artifact.is_initialized);
            assert(!artifact.burned);
            assert(!self.internal.is_spaceship(artifact.artifact_type));
            assert(planet.planet_level > artifact.rarity);

            let mut planet_artifacts = self.storage.planet_artifacts.at(location_id).read();
            if withdrawing {
                let current_location =
                    self.storage.artifact_locations.at(artifact_id).read();
                assert(current_location == location_id);
                assert(self.internal.planet_artifacts_contains(
                    planet_artifacts,
                    artifact_id
                ));
                planet_artifacts =
                    self.internal.planet_artifacts_remove(planet_artifacts, artifact_id);
                self.storage.planet_artifacts.at(location_id).write(planet_artifacts);
                self.storage.artifact_locations.at(artifact_id).write(0);

                let contract_addr = self.context.this_address();
                self.internal.nft_transfer(contract_addr, player, artifact_id);
            } else {
                let current_location =
                    self.storage.artifact_locations.at(artifact_id).read();
                assert(current_location == 0);

                assert(!self.internal.planet_artifacts_contains(planet_artifacts, artifact_id));
                planet_artifacts =
                    self.internal.planet_artifacts_add(planet_artifacts, artifact_id);
                self.storage.planet_artifacts.at(location_id).write(planet_artifacts);
                self.storage.artifact_locations.at(artifact_id).write(location_id);
                let contract_addr = self.context.this_address();
                self.internal.nft_transfer(player, contract_addr, artifact_id);
            }
        } else if action == 12 {
            let artifact_id = x;
            let wormhole_to = y;

            let mut planet = self.storage.planets.at(location_id).read();
            assert(!self.internal.is_planet_destroyed(location_id));

            let mut planet_artifacts = self.storage.planet_artifacts.at(location_id).read();
            assert(self.internal.planet_artifacts_contains(planet_artifacts, artifact_id));

            let mut artifact = self.internal.load_artifact_or_ship(artifact_id);
            assert(artifact.is_initialized);
            assert(!artifact.burned);
            let is_ship = self.internal.is_spaceship(artifact.artifact_type);

            let current_block = self.context.block_number();
            if is_ship {
                assert(artifact.artifact_type == ARTIFACT_TYPE_SHIP_CRESCENT);
                assert(wormhole_to == 0);
                assert(planet.owner.eq(AztecAddress::zero()));
                assert(planet.planet_type != PLANET_TYPE_SILVER_MINE);
                assert(planet.planet_level >= 1);
                assert(artifact.activations == 0);

                artifact.last_activated = current_block;
                artifact.last_deactivated = current_block;
                if planet.silver == 0 {
                    planet.silver = 1;
                    let default_planet = self.internal.default_planet_from_stats(
                        AztecAddress::zero(),
                        location_id,
                        planet.perlin,
                        planet.planet_level,
                        PLANET_TYPE_SILVER_MINE,
                        planet.space_type,
                        false,
                        current_block,
                    );
                    planet.silver_growth = default_planet.silver_growth;
                }
                planet.planet_type = PLANET_TYPE_SILVER_MINE;
                artifact.activations += 1;
                self.storage.artifacts.at(artifact_id).write(artifact);
                self.storage.planets.at(location_id).write(planet);
            } else {
                assert(planet.owner.eq(player));
                assert(artifact.artifact_type < 10u8);

                let active = self.internal.get_active_artifact(location_id);
                assert(!active.is_initialized);

                let cooldown = ARTIFACT_COOLDOWN_BLOCKS[artifact.artifact_type as u32];
                if artifact.last_deactivated != 0 {
                    assert(current_block > artifact.last_deactivated + cooldown);
                }

                if artifact.artifact_type == ARTIFACT_TYPE_WORMHOLE {
                    assert(wormhole_to != 0);
                    let target = self.storage.planets.at(wormhole_to).read();
                    assert(target.is_initialized);
                    assert(!self.internal.is_planet_destroyed(wormhole_to));
                    assert(target.owner.eq(player));
                    artifact.wormhole_to = wormhole_to;
                } else {
                    assert(wormhole_to == 0);
                }

                artifact.last_activated = current_block;
                artifact.activations += 1;

                let mut should_burn = false;
                if artifact.artifact_type == ARTIFACT_TYPE_BLOOM_FILTER {
                    assert(((artifact.rarity as u16) * 2u16) >= (planet.planet_level as u16));
                    planet.population = planet.population_cap;
                    planet.silver = planet.silver_cap;
                    should_burn = true;
                } else if artifact.artifact_type == ARTIFACT_TYPE_BLACK_DOMAIN {
                    assert(((artifact.rarity as u16) * 2u16) >= (planet.planet_level as u16));
                    self.storage.planet_destroyed.at(location_id).write(1);
                    should_burn = true;
                }

                let upgrade = self.internal.upgrade_for_artifact(artifact);
                planet = self.internal.buff_planet(planet, upgrade);

                if should_burn {
                    artifact.last_deactivated = current_block;
                    artifact.wormhole_to = 0;
                    artifact.burned = true;
                    planet_artifacts =
                        self.internal.planet_artifacts_remove(planet_artifacts, artifact_id);
                    self.storage.planet_artifacts.at(location_id).write(planet_artifacts);
                    self.storage
                        .artifact_locations
                        .at(artifact_id)
                        .write(config.max_location_id);
                    let contract_addr = self.context.this_address();
                    let burn_addr = contract_addr;
                    self.internal.nft_transfer(
                        contract_addr,
                        burn_addr,
                        artifact_id,
                    );
                }

                self.storage.artifacts.at(artifact_id).write(artifact);
                self.storage.planets.at(location_id).write(planet);
            }
        } else if action == 13 {
            let _ = self.internal.execute_deactivate_artifact(player, location_id);
        } else if ADMIN_ACTIONS_ENABLED {
            let stored_admin = self.storage.admin.read();
            assert(player.eq(stored_admin));
            if action == 6 {
                let mut planet = self.storage.planets.at(location_id).read();
                planet.silver =
                    if perlin > planet.silver_cap { planet.silver_cap } else { perlin };
                self.storage.planets.at(location_id).write(planet);
            } else if action == 7 {
                let owner = AztecAddress::deserialize([y]);
                let mut planet = self.storage.planets.at(location_id).read();
                planet.owner = owner;
                self.storage.planets.at(location_id).write(planet);
            } else if action == 8 {
                let mut planet = self.storage.planets.at(location_id).read();
                planet.planet_type = perlin as u8;
                planet.planet_level = radius as u8;
                self.storage.planets.at(location_id).write(planet);

            } else if action == 9 {
                let artifact_id = x;
                let owner = AztecAddress::deserialize([y]);
                let value0 = perlin;
                let value1 = radius;
                let value2 = config_hash as u64;

                let mut planet_artifacts = self.storage.planet_artifacts.at(location_id).read();
                planet_artifacts = self.internal.planet_artifacts_add(planet_artifacts, artifact_id);

                let artifact = Artifact::new(
                    artifact_id,
                    location_id,
                    value1 as u8,
                    value2 as u8,
                    owner,
                    value0 as u8,
                );

                self.storage.artifacts.at(artifact_id).write(artifact);
                self.storage.planet_artifacts.at(location_id).write(planet_artifacts);
                self.storage.artifact_locations.at(artifact_id).write(location_id);
                self.internal.nft_mint(owner, artifact_id);
            } else {
                assert(false);
            }
        } else {
            assert(false);
        }
    }

    #[external("private")]
    fn reveal_location(
        x: Field,
        y: Field,
        planethash_key: Field,
        spacetype_key: Field,
        perlin_length_scale: u64,
        perlin_mirror_x: bool,
        perlin_mirror_y: bool,
        expected_config_hash: Field,
        max_location_id: Field,
    ) {
        let player = self.context.msg_sender().unwrap();

        let x_abs = field_abs_u128(x);
        let y_abs = field_abs_u128(y);
        assert(x_abs <= MAX_COORD_ABS);
        assert(y_abs <= MAX_COORD_ABS);

        let perlin_u64 = multi_scale_perlin(
            x,
            y,
            spacetype_key,
            perlin_length_scale,
            perlin_mirror_x,
            perlin_mirror_y,
        );
        let cfg_hash = config_hash(
            planethash_key,
            spacetype_key,
            perlin_length_scale,
            perlin_mirror_x,
            perlin_mirror_y,
        );

        let location_id = mimc_sponge_2_220(x, y, planethash_key);
        assert(cfg_hash == expected_config_hash);
        assert(bn254::lt(location_id, max_location_id));

        self.enqueue(
            DarkForest::at(self.context.this_address()).apply_player_action(
                player,
                location_id,
                x,
                y,
                perlin_u64,
                0,
                cfg_hash,
                1,
            )
        );
    }

    #[external("private")]
    fn upgrade_planet(location_id: Field, branch: u8) {
        let player = self.context.msg_sender().unwrap();
        self.enqueue(
            DarkForest::at(self.context.this_address()).apply_player_action(
                player,
                location_id,
                0,
                0,
                0,
                branch as u64,
                0,
                3,
            )
        );
    }

    #[internal("public")]
    fn execute_upgrade_planet(
        player: AztecAddress,
        location_id: Field,
        branch: u8,
    ) {
        assert(branch < 3);

        let current_block = self.context.block_number();
        self.internal.process_pending_arrivals(location_id, current_block);
        let mut planet = self.storage.planets.at(location_id).read();
        planet = self.internal.refresh_planet(location_id, planet, current_block);

        assert(planet.owner.eq(player));
        assert(planet.planet_level > 0);
        assert(planet.planet_type == PLANET_TYPE_PLANET);

        let total_level: u8 =
            planet.upgrade_state0 + planet.upgrade_state1 + planet.upgrade_state2;
        let max_total: u8 = if planet.space_type == SPACE_TYPE_NEBULA {
            3
        } else if planet.space_type == SPACE_TYPE_SPACE {
            4
        } else {
            5
        };
        assert(total_level < max_total);

        let mut branch_level: u8 = 0;
        if branch == UPGRADE_BRANCH_DEFENSE {
            branch_level = planet.upgrade_state0;
        } else if branch == UPGRADE_BRANCH_RANGE {
            branch_level = planet.upgrade_state1;
        } else if branch == UPGRADE_BRANCH_SPEED {
            branch_level = planet.upgrade_state2;
        }
        assert(branch_level < 4);

        let total_level_u64 = total_level as u64;
        let upgrade_cost = ((planet.silver_cap as u128) * 20u128 * ((total_level_u64 + 1) as u128)) / 100u128;
        assert((planet.silver as u128) >= upgrade_cost);

        let idx = branch as u32;
        planet.population_cap =
            ((planet.population_cap as u128) * (UPGRADE_POP_CAP_MULTIPLIER[idx] as u128) / 100u128) as u64;
        planet.population_growth =
            ((planet.population_growth as u128) * (UPGRADE_POP_GROWTH_MULTIPLIER[idx] as u128) / 100u128) as u64;
        planet.range =
            ((planet.range as u128) * (UPGRADE_RANGE_MULTIPLIER[idx] as u128) / 100u128) as u64;
        planet.speed =
            ((planet.speed as u128) * (UPGRADE_SPEED_MULTIPLIER[idx] as u128) / 100u128) as u64;
        planet.defense =
            ((planet.defense as u128) * (UPGRADE_DEFENSE_MULTIPLIER[idx] as u128) / 100u128) as u64;

        planet.silver = ((planet.silver as u128) - upgrade_cost) as u64;
        if branch == UPGRADE_BRANCH_DEFENSE {
            planet.upgrade_state0 += 1;
        } else if branch == UPGRADE_BRANCH_RANGE {
            planet.upgrade_state1 += 1;
        } else if branch == UPGRADE_BRANCH_SPEED {
            planet.upgrade_state2 += 1;
        }

        self.storage.planets.at(location_id).write(planet);
    }

    #[external("private")]
    fn admin_set_planet_silver(location_id: Field, silver: u64) {
        let admin = self.context.msg_sender().unwrap();
        self.enqueue(
            DarkForest::at(self.context.this_address()).apply_player_action(
                admin,
                location_id,
                0,
                0,
                silver,
                0,
                0,
                6,
            )
        );
    }

    #[external("private")]
    fn admin_set_planet_owner(location_id: Field, owner: AztecAddress) {
        let admin = self.context.msg_sender().unwrap();
        self.enqueue(
            DarkForest::at(self.context.this_address()).apply_player_action(
                admin,
                location_id,
                0,
                owner.to_field(),
                0,
                0,
                0,
                7,
            )
        );
    }

    #[external("private")]
    fn admin_set_planet_type_and_level(
        location_id: Field,
        planet_type: u8,
        planet_level: u8,
    ) {
        let admin = self.context.msg_sender().unwrap();
        self.enqueue(
            DarkForest::at(self.context.this_address()).apply_player_action(
                admin,
                location_id,
                0,
                0,
                planet_type as u64,
                planet_level as u64,
                0,
                8,
            )
        );
    }

    #[external("private")]
    fn admin_create_artifact_on_planet(
        location_id: Field,
        artifact_id: Field,
        artifact_type: u8,
        rarity: u8,
        biome: u8,
        owner: AztecAddress,
    ) {
        let admin = self.context.msg_sender().unwrap();
        self.enqueue(
            DarkForest::at(self.context.this_address()).apply_player_action(
                admin,
                location_id,
                artifact_id,
                owner.to_field(),
                artifact_type as u64,
                rarity as u64,
                biome as Field,
                9,
            )
        );
    }

    #[external("private")]
    fn prospect_planet(location_id: Field) {
        let player = self.context.msg_sender().unwrap();
        self.enqueue(

            DarkForest::at(self.context.this_address()).apply_player_action(
                player,
                location_id,
                0,
                0,
                0,
                0,
                0,
                4,
            )
        );
    }

    #[external("private")]
    fn find_artifact(
        x: Field,
        y: Field,
        biomebase: u64,
        planethash_key: Field,
        biomebase_key: Field,
        perlin_length_scale: u64,
        perlin_mirror_x: bool,
        perlin_mirror_y: bool,
        expected_config_hash: Field,
        max_location_id: Field,
    ) {
        let player = self.context.msg_sender().unwrap();
        let location_id = mimc_sponge_2_220(x, y, planethash_key);

        let x_abs = field_abs_u128(x);
        let y_abs = field_abs_u128(y);
        assert(x_abs <= MAX_COORD_ABS);
        assert(y_abs <= MAX_COORD_ABS);
        let computed_biomebase = multi_scale_perlin(
            x,
            y,
            biomebase_key,
            perlin_length_scale,
            perlin_mirror_x,
            perlin_mirror_y,
        );
        assert(computed_biomebase == biomebase);
        let cfg_hash = config_hash(
            planethash_key,
            biomebase_key,
            perlin_length_scale,
            perlin_mirror_x,
            perlin_mirror_y,
        );
        assert(cfg_hash == expected_config_hash);
        assert(bn254::lt(location_id, max_location_id));

        self.enqueue(
            DarkForest::at(self.context.this_address()).apply_player_action(
                player,
                location_id,
                0,
                0,
                biomebase,
                0,
                cfg_hash,
                5,
            )
        );
    }

    #[external("private")]
    fn trade_artifact(location_id: Field, artifact_id: Field, withdrawing: bool) {
        let player = self.context.msg_sender().unwrap();
        let action = if withdrawing { 11 } else { 10 };
        self.enqueue(
            DarkForest::at(self.context.this_address()).apply_player_action(
                player,
                location_id,
                artifact_id,
                0,
                0,
                0,
                0,
                action,
            )
        );
    }

    #[external("private")]
    fn give_space_ships(location_id: Field) {
        let player = self.context.msg_sender().unwrap();
        self.enqueue(
            DarkForest::at(self.context.this_address()).apply_player_action(
                player,
                location_id,
                0,
                0,
                0,
                0,
                0,
                2,
            )
        );
    }

    #[internal("public")]
    fn execute_deactivate_artifact(
        player: AztecAddress,
        location_id: Field,
    ) -> pub Planet {
        let mut planet = self.storage.planets.at(location_id).read();
        assert(!self.internal.is_planet_destroyed(location_id));
        assert(planet.owner.eq(player));

        let mut artifact = self.internal.get_active_artifact(location_id);
        assert(artifact.is_initialized);

        let current_block = self.context.block_number();
        artifact.last_deactivated = current_block;
        artifact.wormhole_to = 0;

        let upgrade = self.internal.upgrade_for_artifact(artifact);
        planet = self.internal.debuff_planet(planet, upgrade);

        let should_burn = (artifact.artifact_type == ARTIFACT_TYPE_PLANETARY_SHIELD)
            | (artifact.artifact_type == ARTIFACT_TYPE_PHOTOID_CANNON);
        if should_burn {
            let mut planet_artifacts = self.storage.planet_artifacts.at(location_id).read();
            assert(self.internal.planet_artifacts_contains(planet_artifacts, artifact.id));
            planet_artifacts = self.internal.planet_artifacts_remove(planet_artifacts, artifact.id);
            self.storage.planet_artifacts.at(location_id).write(planet_artifacts);
            let burn_location_id = self.storage.config.read().max_location_id;
            self.storage
                .artifact_locations
                .at(artifact.id)
                .write(burn_location_id);
            artifact.burned = true;
            let contract_addr = self.context.this_address();
            self.internal.nft_transfer(contract_addr, contract_addr, artifact.id);
        }

        self.storage.artifacts.at(artifact.id).write(artifact);
        self.storage.planets.at(location_id).write(planet);
        planet
    }

    #[external("private")]
    fn set_artifact_activation(
        location_id: Field,
        artifact_id: Field,
        wormhole_to: Field,
        activate: bool,
    ) {
        let player = self.context.msg_sender().unwrap();
        let action = if activate { 12 } else { 13 };
        self.enqueue(
            DarkForest::at(self.context.this_address()).apply_player_action(
                player,
                location_id,
                artifact_id,
                wormhole_to,
                0,
                0,
                0,
                action,
            )
        );
    }

    #[external("private")]
    fn move(
        x1: Field,
        y1: Field,
        x2: Field,
        y2: Field,
        radius: u64,
        dist_max: u64,
        pop_moved: u64,
        silver_moved: u64,
        moved_artifact_id: Field,
        abandoning: bool,
        planethash_key: Field,
        spacetype_key: Field,
        perlin_length_scale: u64,
        perlin_mirror_x: bool,
        perlin_mirror_y: bool,
        expected_config_hash: Field,
        max_location_id: Field,
        world_radius: u64,
    ) {
        let player = self.context.msg_sender().unwrap();

        let x1_abs = field_abs_u128(x1);
        let y1_abs = field_abs_u128(y1);
        let x2_abs = field_abs_u128(x2);
        let y2_abs = field_abs_u128(y2);
        assert(x1_abs <= MAX_COORD_ABS);
        assert(y1_abs <= MAX_COORD_ABS);
        assert(x2_abs <= MAX_COORD_ABS);
        assert(y2_abs <= MAX_COORD_ABS);

        let r_u = radius as u128;
        let dist_from_origin_sq = x2_abs * x2_abs + y2_abs * y2_abs;
        let r_sq = r_u * r_u;
        assert(dist_from_origin_sq < r_sq);

        let diff_x = signed_sub(field_to_signed(x1), field_to_signed(x2));
        let diff_y = signed_sub(field_to_signed(y1), field_to_signed(y2));
        let dist_sq = diff_x.mag * diff_x.mag + diff_y.mag * diff_y.mag;
        let dist_max_u = dist_max as u128;
        assert(dist_sq <= dist_max_u * dist_max_u);

        let perlin_u64 = multi_scale_perlin(
            x2,
            y2,
            spacetype_key,
            perlin_length_scale,
            perlin_mirror_x,
            perlin_mirror_y,
        );
        let cfg_hash = config_hash(
            planethash_key,
            spacetype_key,
            perlin_length_scale,
            perlin_mirror_x,
            perlin_mirror_y,
        );

        let from_location_id = mimc_sponge_2_220(x1, y1, planethash_key);
        let to_location_id = mimc_sponge_2_220(x2, y2, planethash_key);
        assert(cfg_hash == expected_config_hash);
        assert(radius <= world_radius);
        assert(bn254::lt(to_location_id, max_location_id));

        let move_config: u128 =
            ((dist_max as u128) << 64) | (radius as u128);
        let move_resources: u128 =
            ((silver_moved as u128) << 64) | (pop_moved as u128);

        self.enqueue(
            DarkForest::at(self.context.this_address()).apply_move(
                player,
                from_location_id,
                to_location_id,
                perlin_u64,
                move_config,
                move_resources,
                moved_artifact_id,
                cfg_hash,
                abandoning,
            )
        );
    }

    #[external("private")]
    fn move_known(
        x1: Field,
        y1: Field,
        x2: Field,
        y2: Field,
        radius: u64,
        dist_max: u64,
        pop_moved: u64,
        silver_moved: u64,
        moved_artifact_id: Field,
        abandoning: bool,
        planethash_key: Field,
        spacetype_key: Field,
        perlin_length_scale: u64,
        perlin_mirror_x: bool,
        perlin_mirror_y: bool,
        expected_config_hash: Field,
        max_location_id: Field,
        world_radius: u64,
    ) {
        let player = self.context.msg_sender().unwrap();

        let x1_abs = field_abs_u128(x1);
        let y1_abs = field_abs_u128(y1);
        let x2_abs = field_abs_u128(x2);
        let y2_abs = field_abs_u128(y2);
        assert(x1_abs <= MAX_COORD_ABS);
        assert(y1_abs <= MAX_COORD_ABS);
        assert(x2_abs <= MAX_COORD_ABS);
        assert(y2_abs <= MAX_COORD_ABS);

        let r_u = radius as u128;
        let dist_from_origin_sq = x2_abs * x2_abs + y2_abs * y2_abs;
        let r_sq = r_u * r_u;
        assert(dist_from_origin_sq < r_sq);

        let diff_x = signed_sub(field_to_signed(x1), field_to_signed(x2));
        let diff_y = signed_sub(field_to_signed(y1), field_to_signed(y2));
        let dist_sq = diff_x.mag * diff_x.mag + diff_y.mag * diff_y.mag;
        assert(dist_max < MOVE_KNOWN_FLAG);
        let dist_max_u = dist_max as u128;
        assert(dist_sq <= dist_max_u * dist_max_u);

        let cfg_hash = config_hash(
            planethash_key,
            spacetype_key,
            perlin_length_scale,
            perlin_mirror_x,
            perlin_mirror_y,
        );

        let from_location_id = mimc_sponge_2_220(x1, y1, planethash_key);
        let to_location_id = mimc_sponge_2_220(x2, y2, planethash_key);
        assert(cfg_hash == expected_config_hash);
        assert(radius <= world_radius);
        assert(bn254::lt(to_location_id, max_location_id));

        let dist_max_flagged = dist_max + MOVE_KNOWN_FLAG;
        let move_config: u128 =
            ((dist_max_flagged as u128) << 64) | (radius as u128);
        let move_resources: u128 =
            ((silver_moved as u128) << 64) | (pop_moved as u128);

        self.enqueue(
            DarkForest::at(self.context.this_address()).apply_move(
                player,
                from_location_id,
                to_location_id,
                0,
                move_config,
                move_resources,
                moved_artifact_id,
                cfg_hash,
                abandoning,
            )
        );
    }

    #[external("public")]
    #[only_self]
    fn apply_move(
        player: AztecAddress,
        from_location_id: Field,
        to_location_id: Field,
        perlin: u64,
        move_config: u128,
        move_resources: u128,
        moved_artifact_id: Field,
        config_hash: Field,
        abandoning: bool,
    ) {
        let is_arrival = config_hash == 0;
        if is_arrival {
            let arrival_id = move_config as u64;
            self.internal.execute_arrival(arrival_id);
        } else {
        let config = self.storage.config.read();
        let dist_max_raw = (move_config >> 64) as u64;
        let require_to_initialized = dist_max_raw >= MOVE_KNOWN_FLAG;
        let dist_max = if require_to_initialized {
            dist_max_raw - MOVE_KNOWN_FLAG
        } else {
            dist_max_raw
        };
        let mut pop_moved = move_resources as u64;
        let mut silver_moved = (move_resources >> 64) as u64;

        let current_block = self.context.block_number();
        self.internal.process_pending_arrivals(from_location_id, current_block);
        self.internal.process_pending_arrivals(to_location_id, current_block);

        let mut player_space_junk = self.storage.player_space_junk.at(player).read();
        let player_space_junk_limit = self.storage.player_space_junk_limit.at(player).read();

        let mut from_planet = self.storage.planets.at(from_location_id).read();
        assert(from_planet.is_initialized);
        from_planet = self.internal.refresh_planet(from_location_id, from_planet, current_block);

        let mut moved_artifact = Artifact::empty();
        let mut is_spaceship_move = false;
        if moved_artifact_id != 0 {
            moved_artifact = self.internal.load_artifact_or_ship(moved_artifact_id);
            assert(moved_artifact.is_initialized);
            let from_artifacts = self.storage.planet_artifacts.at(from_location_id).read();
            assert(self.internal.planet_artifacts_contains(from_artifacts, moved_artifact_id));
            assert(!self.internal.is_artifact_active(moved_artifact));
            is_spaceship_move = self.internal.is_spaceship(moved_artifact.artifact_type);
            if is_spaceship_move {
                assert(moved_artifact.discoverer.eq(player));
                assert(pop_moved == 0);
                assert(silver_moved == 0);
            }
        }

        if !is_spaceship_move {
            assert(!self.internal.is_planet_destroyed(from_location_id));
            assert(from_planet.owner.eq(player));
            if !abandoning {
                assert(pop_moved < from_planet.population);
                assert(silver_moved <= from_planet.silver);
            }
        }

        let mut to_planet = self.storage.planets.at(to_location_id).read();
        if !to_planet.is_initialized {
            assert(!require_to_initialized);
            to_planet = self.internal.default_planet(
                AztecAddress::zero(),
                to_location_id,
                perlin,
                false,
                current_block
            );
            // Planet initialization should be one-time across all actions.
            self.context.push_nullifier(to_location_id);
            self.storage.planets.at(to_location_id).write(to_planet);
            self.internal.init_planet_extras(to_location_id, to_planet);
            self.internal.index_touched_planet(to_location_id);
        } else {
            to_planet = self.internal.refresh_planet(to_location_id, to_planet, current_block);
        }
        if !is_spaceship_move {
            assert(!self.internal.is_planet_destroyed(to_location_id));
        }

        if moved_artifact_id != 0 {
            let to_artifacts = self.storage.planet_artifacts.at(to_location_id).read();
            assert(self.internal.planet_artifacts_has_space(to_artifacts));
        }

        let mut arrival_list = self.storage.planet_arrivals.at(to_location_id).read();
        let mut arrivals_from_owner: u8 = 0;
        let mut arrivals_from_others: u8 = 0;
        for i in 0..12 {
            let arrival_id = arrival_list.get(i);
            if arrival_id != 0 {
                let arrival = self.storage.arrivals.at(arrival_id as Field).read();
                if arrival.arrival_block() != 0 {
                    if arrival.player.eq(to_planet.owner) {
                        arrivals_from_owner += 1;
                    } else {
                        arrivals_from_others += 1;
                    }
                }
            }
        }

        if player.eq(to_planet.owner) {
            assert(arrivals_from_owner < MAX_ARRIVALS_PER_BUCKET);
        } else {
            assert(arrivals_from_others < MAX_ARRIVALS_PER_BUCKET);
        }

        let mut arrival_type = ARRIVAL_TYPE_NORMAL;
        let mut effective_dist_times_hundred = dist_max * 100;
        let mut effective_dist = dist_max;
        let mut temp_upgrade = self.internal.default_upgrade();
        let mut arrival_player = player;
        let mut remaining_origin_population = if from_planet.population > pop_moved {
            from_planet.population - pop_moved
        } else {
            0
        };

        if is_spaceship_move {
            arrival_player = AztecAddress::zero();
            from_planet =
                self.internal.apply_spaceship_depart(
                    moved_artifact,
                    from_location_id,
                    from_planet,
                    current_block
                );
        }

        let active_from = self.internal.get_active_artifact(from_location_id);
        let active_to = self.internal.get_active_artifact(to_location_id);
        let mut wormhole = Artifact::empty();
        if active_from.is_initialized
            & (active_from.artifact_type == ARTIFACT_TYPE_WORMHOLE)
            & (active_from.wormhole_to == to_location_id)
        {
            wormhole = active_from;
        } else if active_to.is_initialized
            & (active_to.artifact_type == ARTIFACT_TYPE_WORMHOLE)
            & (active_to.wormhole_to == from_location_id)
        {
            wormhole = active_to;
        }

        if wormhole.is_initialized {
            arrival_type = ARRIVAL_TYPE_WORMHOLE;
            let modifier = WORMHOLE_SPEED_MODIFIERS[wormhole.rarity as u32];
            effective_dist_times_hundred = effective_dist_times_hundred / modifier;
            effective_dist = effective_dist / modifier;
        }

        if !is_spaceship_move {
            if active_from.is_initialized
                & (active_from.artifact_type == ARTIFACT_TYPE_PHOTOID_CANNON)
            {
                if current_block >= active_from.last_activated {
                    let elapsed = current_block - active_from.last_activated;
                    if elapsed >= PHOTOID_ACTIVATION_DELAY_BLOCKS {
                        arrival_type = ARRIVAL_TYPE_PHOTOID;
                        temp_upgrade = self.internal.time_delay_upgrade(active_from);
                        from_planet =
                            self.internal.execute_deactivate_artifact(player, from_location_id);
                    }
                }
            }
        }

                }
            }
        }

        let mut player_dirty = false;
        if (!is_spaceship_move) & abandoning {
            assert(!self.internal.planet_has_arrivals(from_location_id));
            assert(!from_planet.is_home_planet);

            pop_moved = from_planet.population;
            silver_moved = from_planet.silver;
            let default_planet = self.internal.default_planet_from_stats(
                AztecAddress::zero(),
                from_location_id,
                from_planet.perlin,
                from_planet.planet_level,
                from_planet.planet_type,
                from_planet.space_type,
                false,
                current_block,
            );
            remaining_origin_population = default_planet.population * 2;
            temp_upgrade = self.internal.abandoning_upgrade();

            let mut planet_space_junk = self.internal.planet_default_space_junk(from_planet);
            if self.internal.is_half_space_junk(from_location_id) {
                planet_space_junk /= 2;
            }
            if planet_space_junk >= player_space_junk {
                player_space_junk = 0;
            } else {
                player_space_junk -= planet_space_junk;
            }
            self.storage
                .planet_space_junk
                .at(from_location_id)
                .write(planet_space_junk);
            from_planet.owner = AztecAddress::zero();
            player_dirty = true;
        }

        if !is_spaceship_move {
            let to_space_junk = self.storage.planet_space_junk.at(to_location_id).read();
            if to_space_junk != 0 {
                assert(
                    (player_space_junk + to_space_junk)
                        <= player_space_junk_limit
                );
                player_space_junk += to_space_junk;
                self.storage.planet_space_junk.at(to_location_id).write(0);
                player_dirty = true;
            }
        }

        let move_planet = self.internal.buff_planet(from_planet, temp_upgrade);
        let pop_arriving = self.internal.decayed_population(
            pop_moved,
            effective_dist,
            move_planet.range,
            move_planet.population_cap,
        );
        if !is_spaceship_move {
            assert(pop_arriving > 0);
        }

        let time_factor = config.time_factor_hundredths;
        let time_factor_u = if time_factor == 0 { 1 } else { time_factor } as u128;
        let mut travel_time =
            (effective_dist_times_hundred as u128)
                * 100u128
                / ((move_planet.speed as u128) * time_factor_u);
        if travel_time == 0 {
            travel_time = 1;
        }

        let departure_block = current_block;
        let arrival_block_u64 = (departure_block as u64) + (travel_time as u64);
        let arrival_block = arrival_block_u64 as u32;
        let arrival_id = self.storage.next_arrival_id.read();
        let arrival_key = arrival_id as Field;

        let mut inserted = false;
        for i in 0..12 {
            if !inserted {
                if arrival_list.get(i) == 0 {
                    arrival_list = arrival_list.set(i, arrival_id);
                    inserted = true;
                }
            }
        }
        assert(inserted);
        self.storage.planet_arrivals.at(to_location_id).write(arrival_list);

        let arrival = Arrival::new(
            arrival_player,
            from_location_id,
            to_location_id,
            pop_arriving,
            silver_moved,
            departure_block,
            arrival_block,
            arrival_type,
            dist_max,
            moved_artifact_id,
        );
        self.storage.arrivals.at(arrival_key).write(arrival);
        self.storage.next_arrival_id.write(arrival_id + 1);

        if moved_artifact_id != 0 {
            let mut planet_artifacts = self.storage.planet_artifacts.at(from_location_id).read();
            assert(self.internal.planet_artifacts_contains(
                planet_artifacts,
                moved_artifact_id
            ));
            planet_artifacts =
                self.internal.planet_artifacts_remove(planet_artifacts, moved_artifact_id);
            self.storage.planet_artifacts.at(from_location_id).write(planet_artifacts);
            self.storage.artifact_locations.at(moved_artifact_id).write(0);
        }

        from_planet.population = remaining_origin_population;
        from_planet.silver = from_planet.silver - silver_moved;
        from_planet.last_updated = departure_block;
        self.storage.planets.at(from_location_id).write(from_planet);

        if player_dirty {
            self.storage.player_space_junk.at(player).write(player_space_junk);
        }
    }
    }

    #[external("private")]
    fn resolve_arrival(arrival_id: u64) {
        self.enqueue(
            DarkForest::at(self.context.this_address()).apply_move(
                AztecAddress::zero(),
                0,
                0,
                0,
                arrival_id as u128,
                0,
                0,
                0,
                false,
            )
        );
    }

    #[internal("public")]
    fn execute_arrival(arrival_id: u64) {
        let arrival_key = arrival_id as Field;
        let arrival = self.storage.arrivals.at(arrival_key).read();
        assert(arrival.arrival_block() != 0);

        let current_block = self.context.block_number();
        assert(current_block >= arrival.arrival_block());

        let mut planet = self.storage.planets.at(arrival.to_planet).read();
        assert(planet.last_updated <= arrival.arrival_block());
        planet = self.internal.refresh_planet(
            arrival.to_planet,
            planet,
            arrival.arrival_block(),
        );
        assert(!self.internal.is_planet_destroyed(arrival.to_planet));
        let pausers = self.storage.planet_pausers.at(arrival.to_planet).read();

        let arrival_type = arrival.arrival_type();
        let wormhole_arrival = arrival_type == ARRIVAL_TYPE_WORMHOLE;
        if arrival.player.eq(planet.owner) {
            planet.population = planet.population + arrival.pop_arriving();
        } else if wormhole_arrival {
            // v0.6 parity: LibLazyUpdate.applyArrival skips energy transfer on wormhole arrivals
            // to planets not owned by the initiator (reference/darkforest-v0.6/eth/contracts/libraries/LibLazyUpdate.sol).
        } else {
            let damage = (arrival.pop_arriving() * 100) / planet.defense;
            if planet.population > damage {
                planet.population = planet.population - damage;
            } else {
                if !arrival.player.eq(AztecAddress::zero()) {
                    planet.owner = arrival.player;
                }
                let mut new_pop =
                    arrival.pop_arriving() - ((planet.population * planet.defense) / 100);
                if new_pop == 0 {
                    new_pop = 1;
                }
                planet.population = new_pop;
            }
        }

        if (planet.planet_type == PLANET_TYPE_SILVER_BANK) | (pausers > 0) {
            if planet.population > planet.population_cap {
                planet.population = planet.population_cap;
            }
        }

        let next_silver = planet.silver + arrival.silver_moved();
        if next_silver > planet.silver_cap {
            planet.silver = planet.silver_cap;
        } else {
            planet.silver = next_silver;
        }

        if arrival.carried_artifact_id != 0 {
            let mut planet_artifacts =
                self.storage.planet_artifacts.at(arrival.to_planet).read();
            assert(self.internal.planet_artifacts_has_space(planet_artifacts));
            planet_artifacts = self.internal.planet_artifacts_add(
                planet_artifacts,
                arrival.carried_artifact_id
            );
            self.storage.planet_artifacts.at(arrival.to_planet).write(planet_artifacts);

            let carried = self.internal.load_artifact_or_ship(arrival.carried_artifact_id);
            if carried.is_initialized & self.internal.is_spaceship(carried.artifact_type) {
                planet = self.internal.apply_spaceship_arrive(
                    carried,
                    arrival.to_planet,
                    planet
                );
            }
            self.storage
                .artifact_locations
                .at(arrival.carried_artifact_id)
                .write(arrival.to_planet);
        }

        planet.last_updated = arrival.arrival_block();
        self.storage.planets.at(arrival.to_planet).write(planet);

        let mut arrival_list = self.storage.planet_arrivals.at(arrival.to_planet).read();
        let mut removed = false;
        for i in 0..12 {
            if !removed {
                if arrival_list.get(i) == arrival_id {
                    arrival_list = arrival_list.set(i, 0);
                    removed = true;
                }
            }
        }
        self.storage.planet_arrivals.at(arrival.to_planet).write(arrival_list);
        self.storage.arrivals.at(arrival_key).write(Arrival::empty());
    }
}

===== FILE: packages/contracts/src/mimc.nr =====
Explanation: MiMC hash constants and sponge/feistel functions used for planet/location hashing in Noir.
global MIMC_C_PARTIAL: [Field; 218] = [
    7120861356467848435263064379192047478074060781135320967663101236819528304084,
    5024705281721889198577876690145313457398658950011302225525409148828000436681,
    17980351014018068290387269214713820287804403312720763401943303895585469787384,
    19886576439381707240399940949310933992335779767309383709787331470398675714258,
    1213715278223786725806155661738676903520350859678319590331207960381534602599,
    18162138253399958831050545255414688239130588254891200470934232514682584734511,
    7667462281466170157858259197976388676420847047604921256361474169980037581876,
    7207551498477838452286210989212982851118089401128156132319807392460388436957,
    9864183311657946807255900203841777810810224615118629957816193727554621093838,
    4798196928559910300796064665904583125427459076060519468052008159779219347957,
    17387238494588145257484818061490088963673275521250153686214197573695921400950,
    10005334761930299057035055370088813230849810566234116771751925093634136574742,
    11897542014760736209670863723231849628230383119798486487899539017466261308762,
    16771780563523793011283273687253985566177232886900511371656074413362142152543,
    749264854018824809464168489785113337925400687349357088413132714480582918506,
    3683645737503705042628598550438395339383572464204988015434959428676652575331,
    7556750851783822914673316211129907782679509728346361368978891584375551186255,
    20391289379084797414557439284689954098721219201171527383291525676334308303023,
    18146517657445423462330854383025300323335289319277199154920964274562014376193,
    8080173465267536232534446836148661251987053305394647905212781979099916615292,
    10796443006899450245502071131975731672911747129805343722228413358507805531141,
    5404287610364961067658660283245291234008692303120470305032076412056764726509,
    4623894483395123520243967718315330178025957095502546813929290333264120223168,
    16845753148201777192406958674202574751725237939980634861948953189320362207797,
    4622170486584704769521001011395820886029808520586507873417553166762370293671,
    16688277490485052681847773549197928630624828392248424077804829676011512392564,
    11878652861183667748838188993669912629573713271883125458838494308957689090959,
    2436445725746972287496138382764643208791713986676129260589667864467010129482,
    1888098689545151571063267806606510032698677328923740058080630641742325067877,
    148924106504065664829055598316821983869409581623245780505601526786791681102,
    18875020877782404439294079398043479420415331640996249745272087358069018086569,
    15189693413320228845990326214136820307649565437237093707846682797649429515840,
    19669450123472657781282985229369348220906547335081730205028099210442632534079,
    5521922218264623411380547905210139511350706092570900075727555783240701821773,
    4144769320246558352780591737261172907511489963810975650573703217887429086546,
    10097732913112662248360143041019433907849917041759137293018029019134392559350,
    1720059427972723034107765345743336447947522473310069975142483982753181038321,
    6302388219880227251325608388535181451187131054211388356563634768253301290116,
    6745410632962119604799318394592010194450845483518862700079921360015766217097,
    10858157235265583624235850660462324469799552996870780238992046963007491306222,
    20241898894740093733047052816576694435372877719072347814065227797906130857593,
    10165780782761211520836029617746977303303335603838343292431760011576528327409,
    2832093654883670345969792724123161241696170611611744759675180839473215203706,
    153011722355526826233082383360057587249818749719433916258246100068258954737,
    20196970640587451358539129330170636295243141659030208529338914906436009086943,
    3180973917010545328313139835982464870638521890385603025657430208141494469656,
    17198004293191777441573635123110935015228014028618868252989374962722329283022,
    7642160509228669138628515458941659189680509753651629476399516332224325757132,
    19346204940546791021518535594447257347218878114049998691060016493806845179755,
    11501810868606870391127866188394535330696206817602260610801897042898616817272,
    3113973447392053821824427670386252797811804954746053461397972968381571297505,
    6545064306297957002139416752334741502722251869537551068239642131448768236585,
    5203908808704813498389265425172875593837960384349653691918590736979872578408,
    2246692432011290582160062129070762007374502637007107318105405626910313810224,
    11760570435432189127645691249600821064883781677693087773459065574359292849137,
    5543749482491340532547407723464609328207990784853381797689466144924198391839,
    8837549193990558762776520822018694066937602576881497343584903902880277769302,
    12855514863299373699594410385788943772765811961581749194183533625311486462501,
    5363660674689121676875069134269386492382220935599781121306637800261912519729,
    13162342403579303950549728848130828093497701266240457479693991108217307949435,
    916941639326869583414469202910306428966657806899788970948781207501251816730,
    15618589556584434434009868216186115416835494805174158488636000580759692174228,
    8959562060028569701043973060670353733575345393653685776974948916988033453971,
    16390754464333401712265575949874369157699293840516802426621216808905079127650,
    168282396747788514908709091757591226095443902501365500003618183905496160435,
    8327443473179334761744301768309008451162322941906921742120510244986704677004,
    17213012626801210615058753489149961717422101711567228037597150941152495100640,
    10394369641533736715250242399198097296122982486516256408681925424076248952280,
    17784386835392322654196171115293700800825771210400152504776806618892170162248,
    16533189939837087893364000390641148516479148564190420358849587959161226782982,
    18725396114211370207078434315900726338547621160475533496863298091023511945076,
    7132325028834551397904855671244375895110341505383911719294705267624034122405,
    148317947440800089795933930720822493695520852448386394775371401743494965187,
    19001050671757720352890779127693793630251266879994702723636759889378387053056,
    18824274411769830274877839365728651108434404855803844568234862945613766611460,
    12771414330193951156383998390424063470766226667986423961689712557338777174205,
    11332046574800279729678603488745295198038913503395629790213378101166488244657,
    9607550223176946388146938069307456967842408600269548190739947540821716354749,
    8756385288462344550200229174435953103162307705310807828651304665320046782583,
    176061952957067086877570020242717222844908281373122372938833890096257042779,
    12200212977482648306758992405065921724409841940671166017620928947866825250857,
    10868453624107875516866146499877130701929063632959660262366632833504750028858,
    2016095394399807253596787752134573207202567875457560571095586743878953450738,
    21815578223768330433802113452339488275704145896544481092014911825656390567514,
    4923772847693564777744725640710197015181591950368494148029046443433103381621,
    1813584943682214789802230765734821149202472893379265320098816901270224589984,
    10810123816265612772922113403831964815724109728287572256602010709288980656498,
    1153669123397255702524721206511185557982017410156956216465120456256288427021,
    5007518659266430200134478928344522649876467369278722765097865662497773767152,
    2511432546938591792036639990606464315121646668029252285288323664350666551637,
    32883284540320451295484135704808083452381176816565850047310272290579727564,
    10484856914279112612610993418405543310546746652738541161791501150994088679557,
    2026733759645519472558796412979210009170379159866522399881566309631434814953,
    14731806221235869882801331463708736361296174006732553130708107037190460654379,
    14740327483193277147065845135561988641238516852487657117813536909482068950652,
    18787428285295558781869865751953016580493190547148386433580291216673009884554,
    3804047064713122820157099453648459188816376755739202017447862327783289895072,
    16709604795697901641948603019242067672006293290826991671766611326262532802914,
    11061717085931490100602849654034280576915102867237101935487893025907907250695,
    2821730726367472966906149684046356272806484545281639696873240305052362149654,
    17467794879902895769410571945152708684493991588672014763135370927880883292655,
    1571520786233540988201616650622796363168031165456869481368085474420849243232,
    10041051776251223165849354194892664881051125330236567356945669006147134614302,
    3981753758468103976812813304477670033098707002886030847251581853700311567551,
    4365864398105436789177703571412645548020537580493599380018290523813331678900,
    2391801327305361293476178683853802679507598622000359948432171562543560193350,
    214219368547551689972421167733597094823289857206402800635962137077096090722,
    18192064100315141084242006659317257023098826945893371479835220462302399655674,
    15487549757142039139328911515400805508248576685795694919457041092150651939253,
    10142447197759703415402259672441315777933858467700579946665223821199077641122,
    11246573086260753259993971254725613211193686683988426513880826148090811891866,
    6574066859860991369704567902211886840188702386542112593710271426704432301235,
    11311085442652291634822798307831431035776248927202286895207125867542470350078,
    20977948360215259915441258687649465618185769343138135384346964466965010873779,
    792781492853909872425531014397300057232399608769451037135936617996830018501,
    5027602491523497423798779154966735896562099398367163998686335127580757861872,
    14595204575654316237672764823862241845410365278802914304953002937313300553572,
    13973538843621261113924259058427434053808430378163734641175100160836376897004,
    16395063164993626722686882727042150241125309409717445381854913964674649318585,
    8465768840047024550750516678171433288207841931251654898809033371655109266663,
    21345603324471810861925019445720576814602636473739003852898308205213912255830,
    21171984405852590343970239018692870799717057961108910523876770029017785940991,
    10761027113757988230637066281488532903174559953630210849190212601991063767647,
    6678298831065390834922566306988418588227382406175769592902974103663687992230,
    4993662582188632374202316265508850988596880036291765531885657575099537176757,
    18364168158495573675698600238443218434246806358811328083953887470513967121206,
    3506345610354615013737144848471391553141006285964325596214723571988011984829,
    248732676202643792226973868626360612151424823368345645514532870586234380100,
    10090204501612803176317709245679152331057882187411777688746797044706063410969,
    21297149835078365363970699581821844234354988617890041296044775371855432973500,
    16729368143229828574342820060716366330476985824952922184463387490091156065099,
    4467191506765339364971058668792642195242197133011672559453028147641428433293,
    8677548159358013363291014307402600830078662555833653517843708051504582990832,
    1022951765127126818581466247360193856197472064872288389992480993218645055345,
    1888195070251580606973417065636430294417895423429240431595054184472931224452,
    4221265384902749246920810956363310125115516771964522748896154428740238579824,
    2825393571154632139467378429077438870179957021959813965940638905853993971879,
    19171031072692942278056619599721228021635671304612437350119663236604712493093,
    10780807212297131186617505517708903709488273075252405602261683478333331220733,
    18230936781133176044598070768084230333433368654744509969087239465125979720995,
    16901065971871379877929280081392692752968612240624985552337779093292740763381,
    146494141603558321291767829522948454429758543710648402457451799015963102253,
    2492729278659146790410698334997955258248120870028541691998279257260289595548,
    2204224910006646535594933495262085193210692406133533679934843341237521233504,
    16062117410185840274616925297332331018523844434907012275592638570193234893570,
    5894928453677122829055071981254202951712129328678534592916926069506935491729,
    4947482739415078212217504789923078546034438919537985740403824517728200332286,
    16143265650645676880461646123844627780378251900510645261875867423498913438066,
    397690828254561723549349897112473766901585444153303054845160673059519614409,
    11272653598912269895509621181205395118899451234151664604248382803490621227687,
    15566927854306879444693061574322104423426072650522411176731130806720753591030,
    14222898219492484180162096141564251903058269177856173968147960855133048449557,
    16690275395485630428127725067513114066329712673106153451801968992299636791385,
    3667030990325966886479548860429670833692690972701471494757671819017808678584,
    21280039024501430842616328642522421302481259067470872421086939673482530783142,
    15895485136902450169492923978042129726601461603404514670348703312850236146328,
    7733050956302327984762132317027414325566202380840692458138724610131603812560,
    438123800976401478772659663183448617575635636575786782566035096946820525816,
    814913922521637742587885320797606426167962526342166512693085292151314976633,
    12368712287081330853637674140264759478736012797026621876924395982504369598764,
    2494806857395134874309386694756263421445039103814920780777601708371037591569,
    16101132301514338989512946061786320637179843435886825102406248183507106312877,
    6252650284989960032925831409804233477770646333900692286731621844532438095656,
    9277135875276787021836189566799935097400042171346561246305113339462708861695,
    10493603554686607050979497281838644324893776154179810893893660722522945589063,
    8673089750662709235894359384294076697329948991010184356091130382437645649279,
    9558393272910366944245875920138649617479779893610128634419086981339060613250,
    19012287860122586147374214541764572282814469237161122489573881644994964647218,
    9783723818270121678386992630754842961728702994964214799008457449989291229500,
    15550788416669474113213749561488122552422887538676036667630838378023479382689,
    15016165746156232864069722572047169071786333815661109750860165034341572904221,
    6506225705710197163670556961299945987488979904603689017479840649664564978574,
    10796631184889302076168355684722130903785890709107732067446714470783437829037,
    19871836214837460419845806980869387567383718044439891735114283113359312279540,
    20871081766843466343749609089986071784031203517506781251203251608363835140622,
    5100105771517691442278432864090229416166996183792075307747582375962855820797,
    8777887112076272395250620301071581171386440850451972412060638225741125310886,
    5300440870136391278944213332144327695659161151625757537632832724102670898756,
    1205448543652932944633962232545707633928124666868453915721030884663332604536,
    5542499997310181530432302492142574333860449305424174466698068685590909336771,
    11028094245762332275225364962905938096659249161369092798505554939952525894293,
    19187314764836593118404597958543112407224947638377479622725713735224279297009,
    17047263688548829001253658727764731047114098556534482052135734487985276987385,
    19914849528178967155534624144358541535306360577227460456855821557421213606310,
    2929658084700714257515872921366736697080475676508114973627124569375444665664,
    15092262360719700162343163278648422751610766427236295023221516498310468956361,
    21578580340755653236050830649990190843552802306886938815497471545814130084980,
    1258781501221760320019859066036073675029057285507345332959539295621677296991,
    3819598418157732134449049289585680301176983019643974929528867686268702720163,
    8653175945487997845203439345797943132543211416447757110963967501177317426221,
    6614652990340435611114076169697104582524566019034036680161902142028967568142,
    19212515502973904821995111796203064175854996071497099383090983975618035391558,
    18664315914479294273286016871365663486061896605232511201418576829062292269769,
    11498264615058604317482574216318586415670903094838791165247179252175768794889,
    10814026414212439999107945133852431304483604215416531759535467355316227331774,
    17566185590731088197064706533119299946752127014428399631467913813769853431107,
    14016139747289624978792446847000951708158212463304817001882956166752906714332,
    8242601581342441750402731523736202888792436665415852106196418942315563860366,
    9244680976345080074252591214216060854998619670381671198295645618515047080988,
    12216779172735125538689875667307129262237123728082657485828359100719208190116,
    10702811721859145441471328511968332847175733707711670171718794132331147396634,
    6479667912792222539919362076122453947926362746906450079329453150607427372979,
    15117544653571553820496948522381772148324367479772362833334593000535648316185,
    6842203153996907264167856337497139692895299874139131328642472698663046726780,
    12732823292801537626009139514048596316076834307941224506504666470961250728055,
    6936272626871035740815028148058841877090860312517423346335878088297448888663,
    17297554111853491139852678417579991271009602631577069694853813331124433680030,
    16641596134749940573104316021365063031319260205559553673368334842484345864859,
    7400481189785154329569470986896455371037813715804007747228648863919991399081,
    2273205422216987330510475127669563545720586464429614439716564154166712854048,
    15162538063742142685306302282127534305212832649282186184583465569986719234456,
    5628039096440332922248578319648483863204530861778160259559031331287721255522,
    16085392195894691829567913404182676871326863890140775376809129785155092531260,
    14227467863135365427954093998621993651369686288941275436795622973781503444257,
    18224457394066545825553407391290108485121649197258948320896164404518684305122,
    274945154732293792784580363548970818611304339008964723447672490026510689427,
    11050822248291117548220126630860474473945266276626263036056336623671308219529,
    2119542016932434047340813757208803962484943912710204325088879681995922344971,
];

fn mimc_feistel_220(xl_in: Field, xr_in: Field, k: Field) -> (Field, Field) {
    let mut xl = xl_in;
    let mut xr = xr_in;
    for i in 0..219 {
        let c = if i == 0 { 0 } else { MIMC_C_PARTIAL[(i - 1) as u32] };
        let t = k + xl + c;
        let t2 = t * t;
        let t4 = t2 * t2;
        let t5 = t4 * t;
        let new_xl = xr + t5;
        let new_xr = xl;
        xl = new_xl;
        xr = new_xr;
    }

    let t = k + xl;
    let t2 = t * t;
    let t4 = t2 * t2;
    let t5 = t4 * t;
    let xr_out = xr + t5;
    let xl_out = xl;
    (xl_out, xr_out)
}

fn mimc_feistel_4(xl_in: Field, xr_in: Field, k: Field) -> (Field, Field) {
    let mut xl = xl_in;
    let mut xr = xr_in;
    for i in 0..3 {
        let c = if i == 0 { 0 } else { MIMC_C_PARTIAL[(i - 1) as u32] };

        let t = k + xl + c;
        let t2 = t * t;
        let t4 = t2 * t2;
        let t5 = t4 * t;
        let new_xl = xr + t5;
        let new_xr = xl;
        xl = new_xl;
        xr = new_xr;
    }

    let t = k + xl;
    let t2 = t * t;
    let t4 = t2 * t2;
    let t5 = t4 * t;
    let xr_out = xr + t5;
    let xl_out = xl;
    (xl_out, xr_out)
}

pub fn mimc_sponge_2_220(a: Field, b: Field, k: Field) -> Field {
    let (xl1, xr1) = mimc_feistel_220(a, 0, k);
    let (xl2, _) = mimc_feistel_220(xl1 + b, xr1, k);
    xl2
}

pub fn mimc_sponge_3_4(a: Field, b: Field, c: Field, k: Field) -> Field {
    let (xl1, xr1) = mimc_feistel_4(a, 0, k);
    let (xl2, xr2) = mimc_feistel_4(xl1 + b, xr1, k);
    let (xl3, _) = mimc_feistel_4(xl2 + c, xr2, k);
    xl3
}

===== FILE: packages/contracts/src/perlin.nr =====
Explanation: Perlin noise implementation for space type/biome generation and planet eligibility checks.
use crate::mimc::mimc_sponge_3_4;
use crate::utils::{
    Signed,
    field_to_signed,
    signed_add,
    signed_div_exact,
    signed_from_i64,
    signed_from_u128,
    signed_mul,
    signed_mul_u128,
    signed_neg,
    signed_sub,
    signed_modulo,
    signed_to_field,
    signed_zero,
};

global DENOMINATOR: u128 = 1125899906842624000;
global MAX_PERLIN_VALUE: u128 = 32;

fn random_u4(x: Field, y: Field, scale: Field, key: Field) -> u8 {
    let out = mimc_sponge_3_4(x, y, scale, key);
    let bits: [u1; 254] = out.to_le_bits();
    let mut value: u8 = 0;
    if bits[0] == 1 { value += 1; }
    if bits[1] == 1 { value += 2; }
    if bits[2] == 1 { value += 4; }
    if bits[3] == 1 { value += 8; }
    value
}

fn random_gradient_at(x: Signed, y: Signed, scale: u128, key: Field) -> [Signed; 2] {
    let vecs: [[i64; 2]; 16] = [
        [1000, 0],
        [923, 382],
        [707, 707],
        [382, 923],
        [0, 1000],
        [-383, 923],
        [-708, 707],
        [-924, 382],
        [-1000, 0],
        [-924, -383],
        [-708, -708],
        [-383, -924],
        [-1, -1000],
        [382, -924],
        [707, -708],
        [923, -383],
    ];

    let idx = random_u4(signed_to_field(x), signed_to_field(y), scale as Field, key);
    let mut gx: i64 = 0;
    let mut gy: i64 = 0;
    for i in 0..16 {
        if idx == i as u8 {
            gx = vecs[i as u32][0];
            gy = vecs[i as u32][1];
        }
    }

    let vector_denominator = DENOMINATOR / 1000;
    let gx_signed = signed_from_i64(gx);
    let gy_signed = signed_from_i64(gy);

    [
        signed_mul_u128(gx_signed, vector_denominator),
        signed_mul_u128(gy_signed, vector_denominator),
    ]
}

fn get_corners_and_grads(
    p: [Signed; 2],
    scale: u128,
    key: Field,
) -> ([[Signed; 2]; 4], [[Signed; 2]; 4]) {
    let (x_rem, _) = signed_modulo(p[0], scale);
    let (y_rem, _) = signed_modulo(p[1], scale);

    let rem_x = signed_from_u128(x_rem);
    let rem_y = signed_from_u128(y_rem);
    let scale_signed = signed_from_u128(scale);

    let bottom_left = [signed_sub(p[0], rem_x), signed_sub(p[1], rem_y)];
    let bottom_right = [signed_add(bottom_left[0], scale_signed), bottom_left[1]];
    let top_left = [bottom_left[0], signed_add(bottom_left[1], scale_signed)];
    let top_right = [
        signed_add(bottom_left[0], scale_signed),
        signed_add(bottom_left[1], scale_signed),
    ];

    let bl_grad = random_gradient_at(bottom_left[0], bottom_left[1], scale, key);
    let br_grad = random_gradient_at(bottom_right[0], bottom_right[1], scale, key);
    let tl_grad = random_gradient_at(top_left[0], top_left[1], scale, key);
    let tr_grad = random_gradient_at(top_right[0], top_right[1], scale, key);

    (
        [bottom_left, bottom_right, top_left, top_right],
        [bl_grad, br_grad, tl_grad, tr_grad],
    )
}

fn get_weight(corner: [Signed; 2], p: [Signed; 2], which_corner: u8) -> u128 {
    let mut diff_x = signed_zero();
    let mut diff_y = signed_zero();

    if which_corner == 0 {
        diff_x = signed_sub(p[0], corner[0]);
        diff_y = signed_sub(p[1], corner[1]);
    } else if which_corner == 1 {
        diff_x = signed_sub(corner[0], p[0]);
        diff_y = signed_sub(p[1], corner[1]);
    } else if which_corner == 2 {
        diff_x = signed_sub(p[0], corner[0]);
        diff_y = signed_sub(corner[1], p[1]);
    } else {
        diff_x = signed_sub(corner[0], p[0]);
        diff_y = signed_sub(corner[1], p[1]);
    }

    assert(!diff_x.neg);
    assert(!diff_y.neg);

    let factor_x = DENOMINATOR - diff_x.mag;
    let factor_y = DENOMINATOR - diff_y.mag;
    let nominator = factor_x * factor_y;
    let weight = nominator / DENOMINATOR;
    assert(nominator == weight * DENOMINATOR);
    weight
}

fn dot(a: [Signed; 2], b: [Signed; 2]) -> Signed {
    let prod0 = signed_mul(a[0], b[0]);
    let prod1 = signed_mul(a[1], b[1]);
    let sum = signed_add(prod0, prod1);
    signed_div_exact(sum, DENOMINATOR)
}

fn single_scale_perlin(p: [Signed; 2], scale: u128, key: Field) -> Signed {
    let (coords, grads) = get_corners_and_grads(p, scale, key);
    let scaled_p = [
        signed_mul_u128(p[0], DENOMINATOR),
        signed_mul_u128(p[1], DENOMINATOR),
    ];

    let mut total = signed_zero();
    for i in 0..4 {
        let scaled_corner = [
            signed_mul_u128(coords[i as u32][0], DENOMINATOR),
            signed_mul_u128(coords[i as u32][1], DENOMINATOR),
        ];
        let dist_vec = [
            signed_sub(scaled_p[0], scaled_corner[0]),
            signed_sub(scaled_p[1], scaled_corner[1]),
        ];

        let corner_unit = [
            signed_div_exact(scaled_corner[0], scale),
            signed_div_exact(scaled_corner[1], scale),
        ];
        let p_unit = [
            signed_div_exact(scaled_p[0], scale),
            signed_div_exact(scaled_p[1], scale),
        ];
        let dist_unit = [
            signed_div_exact(dist_vec[0], scale),
            signed_div_exact(dist_vec[1], scale),
        ];

        let weight = get_weight(corner_unit, p_unit, i as u8);
        let dot_val = dot(grads[i as u32], dist_unit);
        let term = signed_div_exact(signed_mul_u128(dot_val, weight), DENOMINATOR);
        total = signed_add(total, term);
    }

    total
}

fn is_power_of_two(value: u64) -> bool {
    if value == 0 { false } else { (value & (value - 1)) == 0 }
}

pub fn multi_scale_perlin(
    x: Field,
    y: Field,
    key: Field,
    scale: u64,
    x_mirror: bool,
    y_mirror: bool,
) -> u64 {
    assert(scale <= 16384);
    assert(is_power_of_two(scale));

    let mut px = field_to_signed(x);
    let mut py = field_to_signed(y);

    if y_mirror {
        if px.neg {
            px = signed_neg(px);
        }
    }
    if x_mirror {
        if py.neg {
            py = signed_neg(py);
        }
    }

    let scale_i = scale as u128;
    let p0 = single_scale_perlin([px, py], scale_i, key);
    let p1 = single_scale_perlin([px, py], scale_i * 2, key);
    let p2 = single_scale_perlin([px, py], scale_i * 4, key);

    let mut total = signed_add(p0, p0);
    total = signed_add(total, p1);
    total = signed_add(total, p2);

    let avg = signed_div_exact(total, 4);
    let scaled = signed_mul_u128(avg, MAX_PERLIN_VALUE / 2);
    let (_, quotient) = signed_modulo(scaled, DENOMINATOR);
    let result = signed_add(quotient, signed_from_u128(MAX_PERLIN_VALUE / 2));

    assert(!result.neg);
    result.mag as u64
}

===== FILE: packages/contracts/src/types.nr =====
Explanation: Core Noir struct and type definitions for config, planets, artifacts, arrivals, and players.
use dep::aztec::protocol_types::{
    address::AztecAddress,
    traits::{Deserialize, Packable, Serialize},
};

pub type ArtifactRarity = u8;
pub type ArtifactType = u8;
pub type Biome = u8;

#[derive(Deserialize, Serialize, Eq, Packable)]
pub struct GameConfig {
    pub planethash_key: Field,
    pub spacetype_key: Field,
    pub biomebase_key: Field,
    pub perlin_length_scale: u64,
    pub perlin_mirror_x: bool,
    pub perlin_mirror_y: bool,
    pub init_perlin_min: u64,
    pub init_perlin_max: u64,
    pub world_radius: u64,
    pub spawn_rim_area: u64,
    pub location_reveal_cooldown: u32,
    pub time_factor_hundredths: u64,
    pub planet_rarity: u64,
    pub max_location_id: Field,
}

impl GameConfig {
    pub fn new(
        planethash_key: Field,
        spacetype_key: Field,
        biomebase_key: Field,
        perlin_length_scale: u64,
        perlin_mirror_x: bool,
        perlin_mirror_y: bool,
        init_perlin_min: u64,
        init_perlin_max: u64,
        world_radius: u64,
        spawn_rim_area: u64,
        location_reveal_cooldown: u32,
        time_factor_hundredths: u64,
        planet_rarity: u64,
        max_location_id: Field,
    ) -> GameConfig {
        Self {
            planethash_key,
            spacetype_key,
            biomebase_key,
            perlin_length_scale,
            perlin_mirror_x,
            perlin_mirror_y,
            init_perlin_min,
            init_perlin_max,
            world_radius,
            spawn_rim_area,
            location_reveal_cooldown,
            time_factor_hundredths,
            planet_rarity,
            max_location_id,
        }
    }
}

#[derive(Deserialize, Serialize, Eq, Packable)]
pub struct Player {
    pub is_initialized: bool,
    pub home_planet: Field,
    pub last_reveal_block: u32,
}

impl Player {
    pub fn empty() -> Player {
        Self {
            is_initialized: false,
            home_planet: 0,
            last_reveal_block: 0,
        }
    }

    pub fn new(
        home_planet: Field,
        last_reveal_block: u32,
    ) -> Player {
        Self {
            is_initialized: true,
            home_planet,
            last_reveal_block,
        }
    }
}

#[derive(Deserialize, Serialize, Eq, Packable)]
pub struct Planet {
    pub is_initialized: bool,
    pub owner: AztecAddress,
    pub perlin: u64,
    pub population: u64,
    pub population_cap: u64,
    pub population_growth: u64,
    pub silver: u64,
    pub silver_cap: u64,
    pub silver_growth: u64,
    pub range: u64,
    pub speed: u64,
    pub defense: u64,
    pub last_updated: u32,
    pub planet_level: u8,
    pub planet_type: u8,
    pub space_type: u8,
    pub is_home_planet: bool,
    pub upgrade_state0: u8,
    pub upgrade_state1: u8,
    pub upgrade_state2: u8,
}

impl Planet {
    pub fn empty() -> Planet {
        Self {
            is_initialized: false,
            owner: AztecAddress::zero(),
            perlin: 0,
            population: 0,
            population_cap: 0,
            population_growth: 0,
            silver: 0,
            silver_cap: 0,
            silver_growth: 0,
            range: 0,
            speed: 0,
            defense: 0,
            last_updated: 0,
            planet_level: 0,
            planet_type: 0,
            space_type: 0,
            is_home_planet: false,
            upgrade_state0: 0,
            upgrade_state1: 0,
            upgrade_state2: 0,
        }
    }

    pub fn new(
        owner: AztecAddress,
        perlin: u64,
        population: u64,
        population_cap: u64,
        population_growth: u64,
        silver: u64,
        silver_cap: u64,
        silver_growth: u64,
        range: u64,
        speed: u64,
        defense: u64,
        last_updated: u32,
        planet_level: u8,
        planet_type: u8,
        space_type: u8,
        is_home_planet: bool,
        upgrade_state0: u8,
        upgrade_state1: u8,
        upgrade_state2: u8,
    ) -> Planet {
        Self {
            is_initialized: true,
            owner,
            perlin,
            population,
            population_cap,
            population_growth,
            silver,
            silver_cap,
            silver_growth,
            range,
            speed,
            defense,
            last_updated,
            planet_level,
            planet_type,
            space_type,
            is_home_planet,
            upgrade_state0,
            upgrade_state1,
            upgrade_state2,
        }
    }
}

#[derive(Deserialize, Serialize, Eq, Packable)]
pub struct Upgrade {
    pub pop_cap_multiplier: u64,
    pub pop_gro_multiplier: u64,
    pub range_multiplier: u64,
    pub speed_multiplier: u64,
    pub def_multiplier: u64,
}

impl Upgrade {
    pub fn new(
        pop_cap_multiplier: u64,
        pop_gro_multiplier: u64,
        range_multiplier: u64,
        speed_multiplier: u64,
        def_multiplier: u64,
    ) -> Upgrade {
        Self {
            pop_cap_multiplier,
            pop_gro_multiplier,
            range_multiplier,
            speed_multiplier,
            def_multiplier,
        }
    }
}

#[derive(Deserialize, Serialize, Eq, Packable)]
pub struct PlanetArtifactState {
    pub has_tried_finding_artifact: bool,
    pub prospected_block_number: u32,
}

impl PlanetArtifactState {
    pub fn empty() -> PlanetArtifactState {
        Self {
            has_tried_finding_artifact: false,
            prospected_block_number: 0,
        }
    }

    pub fn new(
        has_tried_finding_artifact: bool,
        prospected_block_number: u32,
    ) -> PlanetArtifactState {
        Self {
            has_tried_finding_artifact,
            prospected_block_number,
        }
    }
}

#[derive(Deserialize, Serialize, Eq, Packable)]
pub struct PlanetArtifacts {
    pub ids: [Field; 5],
}

impl PlanetArtifacts {
    pub fn empty() -> PlanetArtifacts {
        Self { ids: [0; 5] }
    }
}

#[derive(Deserialize, Serialize, Eq, Packable)]
pub struct Artifact {
    pub is_initialized: bool,
    pub id: Field,
    pub planet_discovered_on: Field,
    pub rarity: ArtifactRarity,
    pub planet_biome: Biome,
    pub discoverer: AztecAddress,
    pub artifact_type: ArtifactType,
    pub activations: u32,
    pub last_activated: u32,
    pub last_deactivated: u32,
    pub wormhole_to: Field,
    pub burned: bool,
}

impl Artifact {
    pub fn empty() -> Artifact {
        Self {
            is_initialized: false,
            id: 0,
            planet_discovered_on: 0,
            rarity: 0,
            planet_biome: 0,
            discoverer: AztecAddress::zero(),
            artifact_type: 0,
            activations: 0,
            last_activated: 0,
            last_deactivated: 0,
            wormhole_to: 0,
            burned: false,
        }
    }

    pub fn new(
        id: Field,
        planet_discovered_on: Field,
        rarity: ArtifactRarity,
        planet_biome: Biome,
        discoverer: AztecAddress,
        artifact_type: ArtifactType,
    ) -> Artifact {
        Self {
            is_initialized: true,
            id,
            planet_discovered_on,
            rarity,
            planet_biome,
            discoverer,
            artifact_type,
            activations: 0,
            last_activated: 0,
            last_deactivated: 0,
            wormhole_to: 0,
            burned: false,
        }
    }
}

#[derive(Deserialize, Serialize, Eq, Packable)]
pub struct ArtifactWithMetadata {
    pub artifact: Artifact,
    pub owner: AztecAddress,
    pub location_id: Field,
}

impl ArtifactWithMetadata {
    pub fn empty() -> ArtifactWithMetadata {
        Self {
            artifact: Artifact::empty(),
            owner: AztecAddress::zero(),
            location_id: 0,
        }
    }
}

#[derive(Deserialize, Serialize, Eq, Packable)]
pub struct RevealedCoords {
    pub location_id: Field,
    pub x: Field,
    pub y: Field,
    pub revealer: AztecAddress,
}

impl RevealedCoords {
    pub fn empty() -> RevealedCoords {
        Self {
            location_id: 0,
            x: 0,
            y: 0,
            revealer: AztecAddress::zero(),
        }
    }

    pub fn new(location_id: Field, x: Field, y: Field, revealer: AztecAddress) -> RevealedCoords {
        Self {
            location_id,
            x,
            y,
            revealer,
        }
    }
}

#[derive(Deserialize, Serialize, Eq, Packable)]
pub struct Arrival {
    pub player: AztecAddress,
    pub from_planet: Field,
    pub to_planet: Field,
    pub pop_silver: u128,
    pub meta: u128,
    pub carried_artifact_id: Field,
}

impl Arrival {
    pub fn empty() -> Arrival {
        Self {
            player: AztecAddress::zero(),
            from_planet: 0,
            to_planet: 0,
            pop_silver: 0,
            meta: 0,
            carried_artifact_id: 0,
        }
    }

    pub fn new(
        player: AztecAddress,
        from_planet: Field,
        to_planet: Field,
        pop_arriving: u64,
        silver_moved: u64,
        departure_block: u32,
        arrival_block: u32,
        arrival_type: u8,
        distance: u64,
        carried_artifact_id: Field,
    ) -> Arrival {
        assert(distance <= 0xFFFF_FFFF);
        let pop_silver = ((pop_arriving as u128) << 64) | (silver_moved as u128);
        let distance_u32 = distance as u32;
        let meta = (departure_block as u128)
            | ((arrival_block as u128) << 32)
            | ((arrival_type as u128) << 64)
            | ((distance_u32 as u128) << 72);
        Self {
            player,
            from_planet,
            to_planet,
            pop_silver,
            meta,
            carried_artifact_id,
        }
    }

    pub fn pop_arriving(self) -> u64 {
        (self.pop_silver >> 64) as u64
    }

    pub fn silver_moved(self) -> u64 {
        (self.pop_silver & 0xFFFF_FFFF_FFFF_FFFF) as u64
    }

    pub fn arrival_block(self) -> u32 {
        ((self.meta >> 32) & 0xFFFF_FFFF) as u32
    }

    pub fn arrival_type(self) -> u8 {
        ((self.meta >> 64) & 0xFF) as u8
    }
}

#[derive(Deserialize, Serialize, Eq, Packable)]
pub struct PlanetArrivals {
    pub ids: [u128; 6],
}

impl PlanetArrivals {
    pub fn empty() -> PlanetArrivals {
        Self { ids: [0; 6] }
    }

    pub fn get(self, idx: u32) -> u64 {
        let pair_index = idx / 2;
        let pair = self.ids[pair_index];
        if (idx & 1) == 0 {
            (pair & 0xFFFF_FFFF_FFFF_FFFF) as u64
        } else {
            ((pair >> 64) & 0xFFFF_FFFF_FFFF_FFFF) as u64
        }
    }

    pub fn set(self, idx: u32, value: u64) -> PlanetArrivals {
        let mut updated = self;
        let pair_index = idx / 2;
        let pair = updated.ids[pair_index];
        let value_u128 = value as u128;
        let low_mask: u128 = 0xFFFF_FFFF_FFFF_FFFF;
        let high_mask: u128 = 0xFFFF_FFFF_FFFF_FFFF_0000_0000_0000_0000;
        let new_pair = if (idx & 1) == 0 {
            (pair & high_mask) | value_u128
        } else {
            (pair & low_mask) | (value_u128 << 64)
        };
        updated.ids[pair_index] = new_pair;
        updated
    }
}

===== FILE: packages/contracts/src/utils.nr =====
Explanation: Shared math helpers and signed-number utilities for contract computations.
use dep::std::field::bn254;

use crate::mimc::mimc_sponge_2_220;

pub fn config_hash(
    planethash_key: Field,
    config_key: Field,
    perlin_length_scale: u64,
    perlin_mirror_x: bool,
    perlin_mirror_y: bool,
) -> Field {
    let flags: u8 = (perlin_mirror_x as u8) + ((perlin_mirror_y as u8) << 1);
    let seed = mimc_sponge_2_220(planethash_key, config_key, 0);
    mimc_sponge_2_220(perlin_length_scale as Field, flags as Field, seed)
}

pub struct Signed {
    pub neg: bool,
    pub mag: u128,
}

global FIELD_MODULUS_HALF: Field =
    10944121435919637611123202872628637544274182200208017171849102093287904247808;

fn normalize(neg: bool, mag: u128) -> Signed {
    if mag == 0 {
        Signed { neg: false, mag: 0 }
    } else {
        Signed { neg, mag }
    }
}

pub fn signed_zero() -> Signed {
    Signed { neg: false, mag: 0 }
}

pub fn signed_from_u128(value: u128) -> Signed {
    normalize(false, value)
}

pub fn signed_from_i64(value: i64) -> Signed {
    if value < 0 {
        normalize(true, (-value) as u128)
    } else {
        normalize(false, value as u128)
    }
}

pub fn signed_neg(value: Signed) -> Signed {
    if value.mag == 0 {
        value
    } else {
        Signed {
            neg: !value.neg,
            mag: value.mag,
        }
    }
}

pub fn signed_add(a: Signed, b: Signed) -> Signed {
    if a.neg == b.neg {
        normalize(a.neg, a.mag + b.mag)
    } else if a.mag >= b.mag {
        normalize(a.neg, a.mag - b.mag)
    } else {
        normalize(b.neg, b.mag - a.mag)
    }
}

pub fn signed_sub(a: Signed, b: Signed) -> Signed {
    signed_add(a, signed_neg(b))
}

pub fn signed_mul(a: Signed, b: Signed) -> Signed {
    let neg = a.neg != b.neg;
    normalize(neg, a.mag * b.mag)
}

pub fn signed_mul_u128(a: Signed, b: u128) -> Signed {
    if a.mag == 0 {
        signed_zero()
    } else if b == 0 {
        signed_zero()
    } else {
        normalize(a.neg, a.mag * b)
    }
}

pub fn signed_div_exact(a: Signed, divisor: u128) -> Signed {
    assert(divisor != 0);
    let quotient = a.mag / divisor;
    assert(a.mag == quotient * divisor);
    normalize(a.neg, quotient)
}

pub fn signed_modulo(a: Signed, divisor: u128) -> (u128, Signed) {
    assert(divisor > 0);
    let raw_remainder = a.mag % divisor;
    let raw_quotient = a.mag / divisor;

    if !a.neg {
        (raw_remainder, normalize(false, raw_quotient))
    } else if raw_remainder == 0 {
        (0, normalize(true, raw_quotient))
    } else {
        let remainder = divisor - raw_remainder;
        let quotient = raw_quotient + 1;
        (remainder, normalize(true, quotient))
    }
}

pub fn field_is_negative(x: Field) -> bool {
    bn254::gt(x, FIELD_MODULUS_HALF)
}

pub fn field_to_signed(x: Field) -> Signed {
    let is_negative = field_is_negative(x);
    if is_negative {
        let mag_field = 0 - x;
        normalize(true, mag_field as u128)
    } else {
        normalize(false, x as u128)
    }
}

pub fn signed_to_field(x: Signed) -> Field {
    let val = x.mag as Field;
    if x.neg { 0 - val } else { val }
}

pub fn field_abs_u128(x: Field) -> u128 {
    field_to_signed(x).mag
}

pub fn pow2_frac_q32(frac: u32) -> u128 {
    let consts: [u64; 32] = [
        6074001000,
        5107605667,
        4683695048,
        4485121744,
        4389014833,
        4341736423,
        4318288544,
        4306612134,
        4300785774,
        4297875550,
        4296421177,
        4295694175,
        4295330720,
        4295149004,
        4295058149,
        4295012722,
        4294990009,
        4294978653,
        4294972974,
        4294970135,
        4294968716,
        4294968006,
        4294967651,
        4294967473,
        4294967385,
        4294967340,
        4294967318,
        4294967307,
        4294967302,
        4294967299,
        4294967297,
        4294967297,
    ];

    let mut result: u128 = 1u128 << 32;
    for i in 0..32 {
        let shift = 31 - i;
        let bit = (frac >> shift) & 1;
        if bit == 1 {
            result = (result * (consts[i] as u128)) >> 32;
        }
    }
    result
}

global INV_LN2_Q32: u64 = 6196328019;

pub fn pow2_q32_from_q32(exp_q32: u128) -> u128 {
    let int_part = (exp_q32 >> 32) as u32;
    let frac_part = (exp_q32 & 0xFFFF_FFFF) as u32;
    let mut result = pow2_frac_q32(frac_part);
    result = result << (int_part as u128);
    result
}

pub fn exp_neg_q32(x_q32: u128) -> u128 {
    let y_q32 = (x_q32 * (INV_LN2_Q32 as u128)) >> 32;
    let y_int = (y_q32 >> 32) as u32;
    let mut result: u128 = 0;
    if y_int < 64 {
        let pow2 = pow2_q32_from_q32(y_q32);
        if pow2 != 0 {
            result = (1u128 << 64) / pow2;
        }
    }
    result
}

===== FILE: packages/contracts/src/test/mod.nr =====
Explanation: Noir test module entrypoint wiring for contract tests.
mod darkforest_stub;
mod utils;

===== FILE: packages/contracts/src/test/utils.nr =====
Explanation: Test helpers and default config constants for Noir contract tests.
use dep::aztec::{
    protocol_types::address::AztecAddress, test::helpers::test_environment::TestEnvironment,
};

use crate::{types::GameConfig, utils::config_hash, DarkForest};
use dep::darkforest_nft::NFT;

pub global PLANETHASH_KEY: Field = 42;
pub global SPACETYPE_KEY: Field = 43;
pub global BIOMEBASE_KEY: Field = 6271;
pub global PERLIN_LENGTH_SCALE: u64 = 1024;
pub global PERLIN_MIRROR_X: bool = false;
pub global PERLIN_MIRROR_Y: bool = false;
pub global INIT_PERLIN_MIN: u64 = 0;
pub global INIT_PERLIN_MAX: u64 = 33;
pub global WORLD_RADIUS: u64 = 10000;
pub global SPAWN_RIM_AREA: u64 = 0;
pub global DEFAULT_REVEAL_COOLDOWN: u32 = 0;
pub global PLANET_RARITY: u64 = 1;
pub global MAX_LOCATION_ID: Field = 0 - 1;
pub global REAL_PLANET_RARITY: u64 = 16384;
pub global REAL_MAX_LOCATION_ID: Field =
    1335952323720658888076562850662675481478782006861330221172986095372058624;
pub global PERLIN_THRESHOLD_1: u64 = 14;
pub global PERLIN_THRESHOLD_2: u64 = 15;
pub global PERLIN_THRESHOLD_3: u64 = 19;
pub global BIOME_THRESHOLD_1: u64 = 15;
pub global BIOME_THRESHOLD_2: u64 = 17;
pub global MAX_NATURAL_PLANET_LEVEL: u8 = 9;
pub global TIME_FACTOR_HUNDREDTHS: u64 = 100;
pub global PLANET_LEVEL_THRESHOLDS: [u64; 10] = [
    16777216,
    4194292,
    1048561,
    262128,
    65520,
    16368,
    4080,
    1008,
    240,
    48,
];
pub global PLANET_TYPE_WEIGHTS: [[[u64; 5]; 10]; 4] = [
    [
        [1, 0, 0, 0, 0],
        [13, 2, 0, 1, 0],
        [13, 2, 0, 1, 0],
        [13, 2, 0, 0, 1],
        [13, 2, 0, 0, 1],
        [13, 2, 0, 0, 1],
        [13, 2, 0, 0, 1],
        [13, 2, 0, 0, 1],
        [13, 2, 0, 0, 1],
        [13, 2, 0, 0, 1],
    ],
    [
        [1, 0, 0, 0, 0],
        [13, 2, 1, 0, 0],
        [12, 2, 1, 1, 0],
        [11, 2, 1, 1, 1],
        [12, 2, 1, 0, 1],
        [12, 2, 1, 0, 1],
        [12, 2, 1, 0, 1],
        [12, 2, 1, 0, 1],
        [12, 2, 1, 0, 1],
        [12, 2, 1, 0, 1],
    ],
    [
        [1, 0, 0, 0, 0],
        [10, 4, 2, 0, 0],
        [10, 4, 1, 1, 0],
        [8, 4, 1, 2, 1],
        [8, 4, 1, 2, 1],
        [8, 4, 1, 2, 1],
        [8, 4, 1, 2, 1],
        [8, 4, 1, 2, 1],
        [8, 4, 1, 2, 1],
        [8, 4, 1, 2, 1],
    ],
    [
        [1, 0, 0, 0, 0],
        [11, 4, 1, 0, 0],
        [11, 4, 1, 0, 0],
        [7, 4, 2, 2, 1],
        [7, 4, 2, 2, 1],
        [7, 4, 2, 2, 1],
        [7, 4, 2, 2, 1],
        [7, 4, 2, 2, 1],
        [7, 4, 2, 2, 1],
        [7, 4, 2, 2, 1],
    ],
];

pub fn spacetype_config_hash() -> Field {
    config_hash(
        PLANETHASH_KEY,
        SPACETYPE_KEY,
        PERLIN_LENGTH_SCALE,
        PERLIN_MIRROR_X,
        PERLIN_MIRROR_Y,
    )
}

pub fn biome_config_hash() -> Field {
    config_hash(
        PLANETHASH_KEY,
        BIOMEBASE_KEY,
        PERLIN_LENGTH_SCALE,
        PERLIN_MIRROR_X,
        PERLIN_MIRROR_Y,
    )
}

pub unconstrained fn setup() -> (TestEnvironment, AztecAddress, AztecAddress) {
    setup_with_params(DEFAULT_REVEAL_COOLDOWN, PLANET_RARITY, MAX_LOCATION_ID)
}

pub unconstrained fn setup_with_cooldown(
    location_reveal_cooldown: u32
) -> (TestEnvironment, AztecAddress, AztecAddress) {
    setup_with_params(location_reveal_cooldown, PLANET_RARITY, MAX_LOCATION_ID)
}

pub unconstrained fn setup_with_params(
    location_reveal_cooldown: u32,
    planet_rarity: u64,
    max_location_id: Field
) -> (TestEnvironment, AztecAddress, AztecAddress) {
    let mut env = TestEnvironment::new();
    let admin = env.create_light_account();

    let config = GameConfig::new(
        PLANETHASH_KEY,
        SPACETYPE_KEY,
        BIOMEBASE_KEY,
        PERLIN_LENGTH_SCALE,
        PERLIN_MIRROR_X,
        PERLIN_MIRROR_Y,
        INIT_PERLIN_MIN,
        INIT_PERLIN_MAX,
        WORLD_RADIUS,
        SPAWN_RIM_AREA,
        location_reveal_cooldown,
        TIME_FACTOR_HUNDREDTHS,
        planet_rarity,
        max_location_id,
    );
    let nft_initializer_call_interface =
        NFT::interface().constructor(admin);
    let nft_contract_address =
        env.deploy("../nft/NFT").with_public_initializer(
            admin,
            nft_initializer_call_interface,
        );

    let initializer_call_interface =
        DarkForest::interface().constructor(admin, config, nft_contract_address);
    let contract_address =
        env.deploy("DarkForest").with_public_initializer(admin, initializer_call_interface);

    env.call_public(
        admin,
        NFT::at(nft_contract_address).set_minter(contract_address),
    );

    (env, contract_address, admin)
}

===== FILE: packages/contracts/src/test/darkforest_stub.nr =====
Explanation: Comprehensive Noir test suite covering core game mechanics and arrivals.
use crate::test::utils;
use crate::{
    mimc::mimc_sponge_2_220,
    perlin::multi_scale_perlin,
    utils::{exp_neg_q32, pow2_frac_q32},
    DarkForest,
};
use dep::aztec::protocol_types::address::AztecAddress;
use dep::aztec::protocol_types::storage::map::derive_storage_slot_in_map;
use dep::aztec::protocol_types::traits::ToField;
use dep::darkforest_nft::NFT;

pub global INIT_X: Field = 990;
pub global INIT_Y: Field = 0;
pub global INIT_RADIUS: u64 = 1000;
// Precomputed for PLANETHASH_KEY=42 with MiMC, valid under PLANET_RARITY=16384.
pub global REAL_INIT_X: Field = 1;
pub global REAL_INIT_Y: Field = 4863;
pub global REAL_INIT_RADIUS: u64 = 4864;

pub global REVEAL_X: Field = 123;
pub global REVEAL_Y: Field = 456;
pub global REVEAL_X_2: Field = 124;
pub global REVEAL_Y_2: Field = 456;
pub global HOME_PLANET_POPULATION: u64 = 200000;
pub global MOVE_X_2: Field = 990;
pub global MOVE_Y_2: Field = 10;
pub global MOVE_DIST_MAX: u64 = 10;
pub global MOVE_POP_MOVED: u64 = 10000;
pub global CAPTURE_X_2: Field = 990;
pub global CAPTURE_Y_2: Field = 1;
pub global CAPTURE_DIST_MAX: u64 = 1;
pub global PLANET_TYPE_PLANET: u8 = 0;
pub global PLANET_TYPE_SILVER_MINE: u8 = 1;
pub global PLANET_TYPE_RUINS: u8 = 2;
pub global PLANET_TYPE_TRADING_POST: u8 = 3;
pub global PLANET_TYPE_SILVER_BANK: u8 = 4;
pub global ARTIFACT_TYPE_UNKNOWN: u8 = 0;
pub global ARTIFACT_TYPE_MONOLITH: u8 = 1;
pub global ARTIFACT_TYPE_COLOSSUS: u8 = 2;
pub global ARTIFACT_TYPE_SPACESHIP: u8 = 3;
pub global ARTIFACT_TYPE_PYRAMID: u8 = 4;
pub global ARTIFACT_TYPE_WORMHOLE: u8 = 5;
pub global ARTIFACT_TYPE_PLANETARY_SHIELD: u8 = 6;
pub global ARTIFACT_TYPE_PHOTOID_CANNON: u8 = 7;
pub global ARTIFACT_TYPE_BLOOM_FILTER: u8 = 8;
pub global ARTIFACT_TYPE_BLACK_DOMAIN: u8 = 9;
pub global ARTIFACT_TYPE_SHIP_MOTHERSHIP: u8 = 10;
pub global ARTIFACT_TYPE_SHIP_CRESCENT: u8 = 11;
pub global ARTIFACT_TYPE_SHIP_WHALE: u8 = 12;
pub global ARTIFACT_TYPE_SHIP_GEAR: u8 = 13;
pub global ARTIFACT_TYPE_SHIP_TITAN: u8 = 14;
pub global ARTIFACT_RARITY_UNKNOWN: u8 = 0;
pub global ARTIFACT_RARITY_COMMON: u8 = 1;
pub global ARTIFACT_RARITY_RARE: u8 = 2;
pub global ARTIFACT_RARITY_EPIC: u8 = 3;
pub global ARTIFACT_RARITY_LEGENDARY: u8 = 4;
pub global ARTIFACT_RARITY_MYTHIC: u8 = 5;
pub global ARRIVAL_TYPE_NORMAL: u8 = 1;
pub global ARRIVAL_TYPE_PHOTOID: u8 = 2;
pub global ARRIVAL_TYPE_WORMHOLE: u8 = 3;
pub global PHOTOID_ACTIVATION_DELAY_BLOCKS: u32 = 4;
pub global WORMHOLE_SPEED_MODIFIERS: [u64; 6] = [1, 2, 4, 8, 16, 32];
pub global SHIP_ID_SALT: u64 = 1000;
pub global BIOME_UNKNOWN: u8 = 0;
pub global BIOME_OCEAN: u8 = 1;
pub global BIOME_FOREST: u8 = 2;
pub global BIOME_GRASSLAND: u8 = 3;
pub global BIOME_TUNDRA: u8 = 4;
pub global BIOME_SWAMP: u8 = 5;
pub global BIOME_DESERT: u8 = 6;
pub global BIOME_ICE: u8 = 7;
pub global BIOME_WASTELAND: u8 = 8;
pub global BIOME_LAVA: u8 = 9;
pub global BIOME_CORRUPTED: u8 = 10;
pub global SPACE_TYPE_NEBULA: u8 = 0;
pub global SPACE_TYPE_SPACE: u8 = 1;
pub global SPACE_TYPE_DEEP_SPACE: u8 = 2;
pub global SPACE_TYPE_DEAD_SPACE: u8 = 3;
pub global UPGRADE_BRANCH_DEFENSE: u8 = 0;
pub global MAX_ADVANCE_BLOCKS: u64 = 220;
pub global SEARCH_MAX_DIST: u64 = 30;
pub global SEARCH_MAX_DIST_RUINS: u64 = 200;
pub global POP_LARGE: u64 = 29999;
pub global U64_MASK: u128 = 0xFFFF_FFFF_FFFF_FFFF;

fn unpack_u64_low(packed: Field) -> u64 {
    let value: u128 = packed as u128;
    (value & U64_MASK) as u64
}

fn unpack_u64_high(packed: Field) -> u64 {
    let value: u128 = packed as u128;
    ((value >> 64) & U64_MASK) as u64
}

fn unpack_arrival_meta(packed: Field) -> (u32, u32, u8) {
    let value: u128 = packed as u128;
    let departure_block = (value & 0xFFFF_FFFF) as u32;
    let arrival_block = ((value >> 32) & 0xFFFF_FFFF) as u32;
    let arrival_type = ((value >> 64) & 0xFF) as u8;
    (departure_block, arrival_block, arrival_type)
}

fn expected_location_id(x: Field, y: Field) -> Field {
    mimc_sponge_2_220(x, y, utils::PLANETHASH_KEY)
}

fn expected_perlin(x: Field, y: Field) -> u64 {
    multi_scale_perlin(
        x,
        y,
        utils::SPACETYPE_KEY,
        utils::PERLIN_LENGTH_SCALE,
        utils::PERLIN_MIRROR_X,
        utils::PERLIN_MIRROR_Y,
    )
}

fn expected_space_type(perlin: u64) -> u8 {
    if perlin >= utils::PERLIN_THRESHOLD_3 {
        SPACE_TYPE_DEAD_SPACE
    } else if perlin >= utils::PERLIN_THRESHOLD_2 {
        SPACE_TYPE_DEEP_SPACE
    } else if perlin >= utils::PERLIN_THRESHOLD_1 {
        SPACE_TYPE_SPACE
    } else {
        SPACE_TYPE_NEBULA
    }
}

fn expected_planet_level(location_id: Field, space_type: u8) -> u8 {
    let loc_bytes: [u8; 32] = location_id.to_be_bytes();
    let mut level_uint: u64 = 0;
    level_uint += (loc_bytes[4] as u64) << 16;
    level_uint += (loc_bytes[5] as u64) << 8;
    level_uint += loc_bytes[6] as u64;

    let mut level: u8 = 0;
    let mut found = false;
    for i in 0..10 {
        let idx = 9 - i;
        let threshold = utils::PLANET_LEVEL_THRESHOLDS[idx];
        if (!found) & (level_uint < threshold) {
            level = idx as u8;
            found = true;
        }
    }

    if (space_type == SPACE_TYPE_NEBULA) & (level > 4u8) {
        level = 4;
    }
    if (space_type == SPACE_TYPE_SPACE) & (level > 5u8) {
        level = 5;
    }
    if level > utils::MAX_NATURAL_PLANET_LEVEL {
        level = utils::MAX_NATURAL_PLANET_LEVEL;
    }

    level
}

fn expected_planet_type(location_id: Field, space_type: u8, level: u8) -> u8 {
    let loc_bytes: [u8; 32] = location_id.to_be_bytes();
    let weights = utils::PLANET_TYPE_WEIGHTS[space_type as u32][level as u32];
    let mut weight_sum: u64 = 0;
    for i in 0..5 {
        weight_sum += weights[i];
    }
    assert(weight_sum > 0);

    let mut thresholds: [u64; 5] = [0; 5];
    let mut remaining = weight_sum;
    for i in 0..5 {
        remaining = remaining - weights[i];
        thresholds[i] = (remaining * 256) / weight_sum;
    }

    let type_byte = loc_bytes[8] as u64;
    let mut planet_type: u8 = 0;
    let mut found = false;
    for i in 0..5 {
        if (!found) & (type_byte >= thresholds[i]) {
            planet_type = i as u8;
            found = true;
        }
    }
    planet_type
}

fn expected_biomebase(x: Field, y: Field) -> u64 {
    multi_scale_perlin(
        x,
        y,
        utils::BIOMEBASE_KEY,
        utils::PERLIN_LENGTH_SCALE,
        utils::PERLIN_MIRROR_X,
        utils::PERLIN_MIRROR_Y,
    )
}

fn expected_biome(space_type: u8, biomebase: u64) -> u8 {
    if space_type == SPACE_TYPE_DEAD_SPACE {
        BIOME_CORRUPTED
    } else {
        let mut biome: u16 = (space_type as u16) * 3u16;
        if biomebase < utils::BIOME_THRESHOLD_1 {
            biome += 1;
        } else if biomebase < utils::BIOME_THRESHOLD_2 {
            biome += 2;
        } else {
            biome += 3;
        }
        biome as u8
    }
}

fn mod_255_from_bits(bits: [u1; 254], skip: u32) -> u8 {
    let mut rem: u16 = 0;
    for i in 0..254 {
        let idx = 253 - i;
        if idx >= skip {
            let mut bit_val: u16 = 0;
            if bits[idx] == 1 {
                bit_val = 1;
            }
            rem = (rem * 2 + bit_val) % 255;
        }
    }
    rem as u8
}

fn seed_last_bytes(seed: Field) -> (u8, u8) {
    let bits: [u1; 254] = seed.to_le_bits();
    let last_byte = mod_255_from_bits(bits, 0);
    let mut seed_mod_256: u32 = 0;
    for i in 0..8 {
        if bits[i] == 1 {
            seed_mod_256 += 1u32 << i;
        }
    }
    let mut second_last = mod_255_from_bits(bits, 8);
    if seed_mod_256 < (last_byte as u32) {
        second_last = if second_last == 0 { 254 } else { second_last - 1 };
    }
    (last_byte, second_last)
}

fn expected_artifact_type_and_bonus(seed: Field, biome: u8) -> (u8, u8) {
    let (last_byte, second_last) = seed_last_bytes(seed);


    let mut artifact_type = ARTIFACT_TYPE_PYRAMID;
    if last_byte < 39u8 {
        artifact_type = ARTIFACT_TYPE_MONOLITH;
    } else if last_byte < 78u8 {
        artifact_type = ARTIFACT_TYPE_COLOSSUS;
    } else if last_byte < 156u8 {
        artifact_type = ARTIFACT_TYPE_PYRAMID;
    } else if last_byte < 171u8 {
        artifact_type = ARTIFACT_TYPE_WORMHOLE;
    } else if last_byte < 186u8 {
        artifact_type = ARTIFACT_TYPE_PLANETARY_SHIELD;
    } else if last_byte < 201u8 {
        artifact_type = ARTIFACT_TYPE_PHOTOID_CANNON;
    } else if last_byte < 216u8 {
        artifact_type = ARTIFACT_TYPE_BLOOM_FILTER;
    } else if last_byte < 231u8 {
        artifact_type = ARTIFACT_TYPE_BLACK_DOMAIN;
    } else {
        if biome == BIOME_ICE {
            artifact_type = ARTIFACT_TYPE_PLANETARY_SHIELD;
        } else if biome == BIOME_LAVA {
            artifact_type = ARTIFACT_TYPE_PHOTOID_CANNON;
        } else if biome == BIOME_WASTELAND {
            artifact_type = ARTIFACT_TYPE_BLOOM_FILTER;
        } else if biome == BIOME_CORRUPTED {
            artifact_type = ARTIFACT_TYPE_BLACK_DOMAIN;
        } else {
            artifact_type = ARTIFACT_TYPE_WORMHOLE;
        }
        // v0.6 parity: rarest bucket forces Photoid Cannon, overriding biome-specific picks.
        artifact_type = ARTIFACT_TYPE_PHOTOID_CANNON;
    }

    let mut bonus: u8 = 0;
    if second_last < 4u8 {
        bonus = 2;
    } else if second_last < 16u8 {
        bonus = 1;
    }

    (artifact_type, bonus)
}

fn expected_artifact_rarity(level: u8) -> u8 {
    if level <= 1u8 {
        ARTIFACT_RARITY_COMMON
    } else if level <= 3u8 {
        ARTIFACT_RARITY_RARE
    } else if level <= 5u8 {
        ARTIFACT_RARITY_EPIC
    } else if level <= 7u8 {
        ARTIFACT_RARITY_LEGENDARY
    } else {
        ARTIFACT_RARITY_MYTHIC
    }
}

fn expected_block_hash(block_number: u32) -> Field {
    mimc_sponge_2_220(block_number as Field, 0, utils::PLANETHASH_KEY)
}

fn expected_artifact_seed(
    location_id: Field,
    contract_address_field: Field,
    prospected_block_number: u32,
) -> Field {
    let block_hash = expected_block_hash(prospected_block_number);
    let seed1 = mimc_sponge_2_220(location_id, contract_address_field, utils::PLANETHASH_KEY);
    mimc_sponge_2_220(seed1, block_hash, utils::PLANETHASH_KEY)
}

fn expected_ship_id(location_id: Field, ship_type: u8) -> Field {
    let salt = (SHIP_ID_SALT + (ship_type as u64)) as Field;
    mimc_sponge_2_220(location_id, salt, utils::PLANETHASH_KEY)
}

fn ceil_sqrt_u128(value: u128, max: u64) -> u64 {
    let mut result: u64 = 0;
    let mut found = false;
    for i in 0..(max + 1) {
        if (!found) & (((i as u128) * (i as u128)) >= value) {
            result = i;
            found = true;
        }
    }
    assert(found);
    result
}

fn decayed_population(pop_moved: u64, dist: u64, range: u64, pop_cap: u64) -> u64 {
    let mut result = 0u64;
    if range != 0 {
        let x_fp = ((dist as u128) << 32) / (range as u128);
        let int_part = (x_fp >> 32) as u32;
        let frac_part = (x_fp & 0xFFFF_FFFF) as u32;

        let pow_frac = pow2_frac_q32(frac_part);
        let pop_scaled = (pop_moved as u128) << 32;
        let pop_after_frac = pop_scaled / pow_frac;
        let pop_after_int = if int_part >= 128 {
            0
        } else {
            pop_after_frac >> (int_part as u128)
        };

        let big_planet_debuff = (pop_cap / 20) as u128;
        result = if pop_after_int > big_planet_debuff {
            (pop_after_int - big_planet_debuff) as u64
        } else {
            0
        };
    }
    result
}

fn expected_population_after_time(
    population: u64,
    pop_cap: u64,
    pop_growth: u64,
    time_elapsed: u128,
    planet_type: u8,
    pausers: u8,
) -> u64 {
    let mut updated = population;
    if time_elapsed != 0 {
        let pop_cap_u = pop_cap as u128;
        let pop_u = updated as u128;
        let prev_pop = updated;
        if (pop_u != 0) & (pop_cap_u != 0) {
            let numerator = (4u128 * (pop_growth as u128)) * time_elapsed;
            let x_q32 = (numerator << 32) / pop_cap_u;
            let exp_neg = exp_neg_q32(x_q32);

            if exp_neg == 0 {
                updated = pop_cap;
            } else {
                let ratio_q32 = (pop_cap_u << 32) / pop_u;
                let mut ratio_minus_one_neg = false;
                let mut ratio_minus_one_mag: u128 = 0;
                if ratio_q32 >= (1u128 << 32) {
                    ratio_minus_one_mag = ratio_q32 - (1u128 << 32);
                } else {
                    ratio_minus_one_mag = (1u128 << 32) - ratio_q32;
                    ratio_minus_one_neg = true;
                }
                let product_mag = (exp_neg * ratio_minus_one_mag) >> 32;
                let denom_q32 = if ratio_minus_one_neg {
                    if product_mag >= (1u128 << 32) {
                        1u128
                    } else {
                        (1u128 << 32) - product_mag
                    }
                } else {
                    (1u128 << 32) + product_mag
                };
                let new_pop = (pop_cap_u << 32) / denom_q32;
                updated = new_pop as u64;
            }

            if (pausers > 0) & (updated > prev_pop) {
                updated = prev_pop;
            }

            if (planet_type == PLANET_TYPE_SILVER_BANK) | (pausers > 0) {
                if updated > pop_cap {
                    updated = pop_cap;
                }
            }
        }
    }
    updated
}

#[test]
unconstrained fn test_initializer_sets_admin() {
    let (mut env, contract_address, admin) = utils::setup();

    env.public_context_at(contract_address, |context| {
        let current_admin = context.storage_read(DarkForest::storage_layout().admin.slot);
        assert_eq(current_admin, admin);
    });
}

#[test]
unconstrained fn test_init_player_sets_home_and_planet() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let location_id = expected_location_id(INIT_X, INIT_Y);
    let perlin = expected_perlin(INIT_X, INIT_Y);

    env.public_context_at(contract_address, |context| {
        let player_slot =
            derive_storage_slot_in_map(DarkForest::storage_layout().players.slot, player);
        let stored_initialized = context.storage_read(player_slot);
        let stored_home = context.storage_read(player_slot + 1);
        assert_eq(stored_initialized, 1);
        assert_eq(stored_home, location_id);

        let planet_slot =
            derive_storage_slot_in_map(DarkForest::storage_layout().planets.slot, location_id);
        let stored_planet_initialized = context.storage_read(planet_slot);
        let stored_owner = context.storage_read(planet_slot + 1);
        let stored_perlin = context.storage_read(planet_slot + 2);
        let stored_population = context.storage_read(planet_slot + 3);
        let stored_planet_level = context.storage_read(planet_slot + 13);
        let stored_planet_type = context.storage_read(planet_slot + 14);
        let stored_space_type = context.storage_read(planet_slot + 15);
        let stored_is_home = context.storage_read(planet_slot + 16);
        assert_eq(stored_planet_initialized, 1);
        assert_eq(stored_owner, player);
        assert_eq(stored_perlin, perlin);
        assert_eq(stored_population, HOME_PLANET_POPULATION);
        assert_eq(stored_planet_level, 0);
        assert_eq(stored_planet_type, PLANET_TYPE_PLANET);
        assert_eq(stored_space_type, expected_space_type(perlin));
        assert_eq(stored_is_home, 1);

        let touched_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().touched_planet_ids.slot,
            0,
        );
        let touched_location = context.storage_read(touched_slot);
        assert_eq(touched_location, location_id);
        let touched_slot1 = derive_storage_slot_in_map(
            DarkForest::storage_layout().touched_planet_ids.slot,
            1,
        );
        let touched_location_1 = context.storage_read(touched_slot1);

        assert_eq(touched_location_1, 0);
    });
}

#[test]
unconstrained fn test_reveal_updates_indexes() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            REVEAL_X,
            REVEAL_Y,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    let home_location_id = expected_location_id(INIT_X, INIT_Y);
    let revealed_location_id = expected_location_id(REVEAL_X, REVEAL_Y);

    env.public_context_at(contract_address, |context| {
        let touched_slot0 = derive_storage_slot_in_map(
            DarkForest::storage_layout().touched_planet_ids.slot,
            0,
        );
        let touched_slot1 = derive_storage_slot_in_map(
            DarkForest::storage_layout().touched_planet_ids.slot,
            1,
        );
        let touched0 = context.storage_read(touched_slot0);
        let touched1 = context.storage_read(touched_slot1);
        assert_eq(touched0, home_location_id);
        assert_eq(touched1, revealed_location_id);

        let revealed_count =
            context.storage_read(DarkForest::storage_layout().revealed_coords_count.slot);
        assert_eq(revealed_count, 1);
        let revealed_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().revealed_coords.slot,
            0,
        );
        let stored_location = context.storage_read(revealed_slot);
        let stored_x = context.storage_read(revealed_slot + 1);
        let stored_y = context.storage_read(revealed_slot + 2);
        let stored_revealer = context.storage_read(revealed_slot + 3);
        assert_eq(stored_location, revealed_location_id);
        assert_eq(stored_x, REVEAL_X);
        assert_eq(stored_y, REVEAL_Y);
        assert_eq(stored_revealer, player);
    });
}

#[test]
unconstrained fn test_init_player_real_planet_rarity() {
    let (mut env, contract_address, _) = utils::setup_with_params(
        utils::DEFAULT_REVEAL_COOLDOWN,
        utils::REAL_PLANET_RARITY,
        utils::REAL_MAX_LOCATION_ID,
    );
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            REAL_INIT_X,
            REAL_INIT_Y,
            REAL_INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::REAL_MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let location_id = expected_location_id(REAL_INIT_X, REAL_INIT_Y);

    env.public_context_at(contract_address, |context| {
        let player_slot =
            derive_storage_slot_in_map(DarkForest::storage_layout().players.slot, player);
        let stored_initialized = context.storage_read(player_slot);
        let stored_home = context.storage_read(player_slot + 1);
        assert_eq(stored_initialized, 1);
        assert_eq(stored_home, location_id);
    });
}

#[test(should_fail)]
unconstrained fn test_fail_init_player_bad_config_hash() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY + 1,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::REAL_MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );
}

#[test(should_fail)]
unconstrained fn test_fail_init_player_location_out_of_range() {
    let (mut env, contract_address, _) = utils::setup_with_params(
        utils::DEFAULT_REVEAL_COOLDOWN,
        utils::PLANET_RARITY,
        0,
    );
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            0,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );
}

#[test(should_fail)]
unconstrained fn test_fail_init_player_duplicate() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );
    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );
}

#[test(should_fail)]
unconstrained fn test_fail_init_player_on_initialized_planet() {
    let (mut env, contract_address, _) = utils::setup();
    let player_one = env.create_light_account();
    let player_two = env.create_light_account();

    env.call_private(
        player_one,
        DarkForest::at(contract_address).reveal_location(
            INIT_X,
            INIT_Y,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );
    let location_id = expected_location_id(INIT_X, INIT_Y);
    env.public_context_at(contract_address, |context| {
        let planet_slot =
            derive_storage_slot_in_map(DarkForest::storage_layout().planets.slot, location_id);
        let stored_planet_initialized = context.storage_read(planet_slot);
        assert_eq(stored_planet_initialized, 1);
    });
    env.call_private(
        player_two,

        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );
}

#[test(should_fail)]
unconstrained fn test_fail_init_player_home_constraints() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    let mut found = false;
    let mut bad_x: Field = 0;
    let mut bad_y: Field = 0;
    let mut bad_radius: u64 = 0;

    for offset in 0..800 {
        let candidate = 200 + offset;
        let x = candidate as Field;
        let y = 0 as Field;
        let perlin = expected_perlin(x, y);
        let perlin_ok = (perlin >= utils::INIT_PERLIN_MIN) & (perlin < utils::INIT_PERLIN_MAX);
        if perlin_ok {
            let location_id = expected_location_id(x, y);
            let space_type = expected_space_type(perlin);
            let level = expected_planet_level(location_id, space_type);
            let planet_type = expected_planet_type(location_id, space_type, level);
            let home_ok = (level == 0) & (planet_type == PLANET_TYPE_PLANET);
            if (!found) & !home_ok {
                found = true;
                bad_x = x;
                bad_y = y;
                bad_radius = (candidate as u64) + 1;
            }
        }
    }
    assert(found);

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            bad_x,
            bad_y,
            bad_radius,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );
}

#[test(should_fail)]
unconstrained fn test_fail_init_outside_ring() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            0,
            0,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );
}

#[test]
unconstrained fn test_reveal_location_sets_coords() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            REVEAL_X,
            REVEAL_Y,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    let location_id = expected_location_id(REVEAL_X, REVEAL_Y);
    let perlin = expected_perlin(REVEAL_X, REVEAL_Y);

    env.public_context_at(contract_address, |context| {
        let reveal_slot =
            derive_storage_slot_in_map(DarkForest::storage_layout().revealed.slot, location_id);
        let stored_location = context.storage_read(reveal_slot);
        let stored_x = context.storage_read(reveal_slot + 1);
        let stored_y = context.storage_read(reveal_slot + 2);
        let stored_revealer = context.storage_read(reveal_slot + 3);
        assert_eq(stored_location, location_id);
        assert_eq(stored_x, REVEAL_X);
        assert_eq(stored_y, REVEAL_Y);
        assert_eq(stored_revealer, player);

        let planet_slot =
            derive_storage_slot_in_map(DarkForest::storage_layout().planets.slot, location_id);
        let stored_planet_initialized = context.storage_read(planet_slot);
        let stored_perlin = context.storage_read(planet_slot + 2);
        assert_eq(stored_planet_initialized, 1);
        assert_eq(stored_perlin, perlin);
    });
}

#[test(should_fail)]
unconstrained fn test_fail_reveal_bad_config_hash() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            REVEAL_X,
            REVEAL_Y,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY + 1,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );
}

#[test]
unconstrained fn test_move_creates_arrival() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let from_location_id = expected_location_id(INIT_X, INIT_Y);
    let to_location_id = expected_location_id(MOVE_X_2, MOVE_Y_2);
    let mut pre_population: u64 = 0;
    let mut pre_pop_cap: u64 = 0;
    let mut pre_pop_growth: u64 = 0;
    let mut pre_last_updated: u64 = 0;
    let mut pre_planet_type: u64 = 0;
    let mut pre_pausers: u64 = 0;
    let pre_population_ref = &mut pre_population;
    let pre_pop_cap_ref = &mut pre_pop_cap;
    let pre_pop_growth_ref = &mut pre_pop_growth;
    let pre_last_updated_ref = &mut pre_last_updated;
    let pre_planet_type_ref = &mut pre_planet_type;
    let pre_pausers_ref = &mut pre_pausers;

    env.public_context_at(contract_address, |context| {
        let planet_slot =
            derive_storage_slot_in_map(DarkForest::storage_layout().planets.slot, from_location_id);
        *pre_population_ref = context.storage_read(planet_slot + 3);
        *pre_pop_cap_ref = context.storage_read(planet_slot + 4);
        *pre_pop_growth_ref = context.storage_read(planet_slot + 5);
        *pre_last_updated_ref = context.storage_read(planet_slot + 12);
        *pre_planet_type_ref = context.storage_read(planet_slot + 14);
        let pausers_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_pausers.slot,
            from_location_id,
        );
        *pre_pausers_ref = context.storage_read(pausers_slot);
    });

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            INIT_X,
            INIT_Y,
            MOVE_X_2,
            MOVE_Y_2,
            utils::WORLD_RADIUS,
            MOVE_DIST_MAX,
            MOVE_POP_MOVED,
            0,
            0,
            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );

    env.public_context_at(contract_address, |context| {
        let next_arrival_id =
            context.storage_read(DarkForest::storage_layout().next_arrival_id.slot);
        assert_eq(next_arrival_id, 2);

        let arrival_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().arrivals.slot,
            1,

        );
        let stored_player = context.storage_read(arrival_slot);
        let stored_from = context.storage_read(arrival_slot + 1);
        let stored_to = context.storage_read(arrival_slot + 2);
        let pop_silver = context.storage_read(arrival_slot + 3);
        let stored_pop_arriving = unpack_u64_high(pop_silver);
        assert_eq(stored_player, player);
        assert_eq(stored_from, from_location_id);
        assert_eq(stored_to, to_location_id);
        assert(stored_pop_arriving > 0);

        let planet_slot =
            derive_storage_slot_in_map(DarkForest::storage_layout().planets.slot, from_location_id);
        let stored_population = context.storage_read(planet_slot + 3);
        let post_last_updated = context.storage_read(planet_slot + 12);
        let time_elapsed = (post_last_updated as u128) - (pre_last_updated as u128);
        let refreshed_population = expected_population_after_time(
            pre_population,
            pre_pop_cap,
            pre_pop_growth,
            time_elapsed,
            pre_planet_type as u8,
            pre_pausers as u8,
        );
        let expected_remaining = if refreshed_population > MOVE_POP_MOVED {
            refreshed_population - MOVE_POP_MOVED
        } else {
            0
        };
        assert(stored_population < pre_population);
        assert_eq(stored_population, expected_remaining);

        let arrival_list_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_arrivals.slot,
            to_location_id,
        );
        let packed = context.storage_read(arrival_list_slot);
        let stored_arrival_id = unpack_u64_low(packed);
        assert_eq(stored_arrival_id, 1);

        let touched_slot1 = derive_storage_slot_in_map(
            DarkForest::storage_layout().touched_planet_ids.slot,
            1,
        );
        let touched1 = context.storage_read(touched_slot1);
        assert_eq(touched1, to_location_id);
    });
}

#[test]
unconstrained fn test_move_known_creates_arrival() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            MOVE_X_2,
            MOVE_Y_2,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    let from_location_id = expected_location_id(INIT_X, INIT_Y);
    let to_location_id = expected_location_id(MOVE_X_2, MOVE_Y_2);
    let mut pre_population: u64 = 0;
    let mut pre_pop_cap: u64 = 0;
    let mut pre_pop_growth: u64 = 0;
    let mut pre_last_updated: u64 = 0;
    let mut pre_planet_type: u64 = 0;
    let mut pre_pausers: u64 = 0;
    let pre_population_ref = &mut pre_population;
    let pre_pop_cap_ref = &mut pre_pop_cap;
    let pre_pop_growth_ref = &mut pre_pop_growth;
    let pre_last_updated_ref = &mut pre_last_updated;
    let pre_planet_type_ref = &mut pre_planet_type;
    let pre_pausers_ref = &mut pre_pausers;

    env.public_context_at(contract_address, |context| {
        let planet_slot =
            derive_storage_slot_in_map(DarkForest::storage_layout().planets.slot, from_location_id);
        *pre_population_ref = context.storage_read(planet_slot + 3);
        *pre_pop_cap_ref = context.storage_read(planet_slot + 4);
        *pre_pop_growth_ref = context.storage_read(planet_slot + 5);
        *pre_last_updated_ref = context.storage_read(planet_slot + 12);
        *pre_planet_type_ref = context.storage_read(planet_slot + 14);
        let pausers_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_pausers.slot,
            from_location_id,
        );
        *pre_pausers_ref = context.storage_read(pausers_slot);
    });

    env.call_private(
        player,
        DarkForest::at(contract_address).move_known(
            INIT_X,
            INIT_Y,
            MOVE_X_2,
            MOVE_Y_2,
            utils::WORLD_RADIUS,
            MOVE_DIST_MAX,
            MOVE_POP_MOVED,
            0,
            0,
            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );

    env.public_context_at(contract_address, |context| {
        let next_arrival_id =
            context.storage_read(DarkForest::storage_layout().next_arrival_id.slot);
        assert_eq(next_arrival_id, 2);

        let arrival_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().arrivals.slot,
            1,
        );
        let stored_player = context.storage_read(arrival_slot);
        let stored_from = context.storage_read(arrival_slot + 1);
        let stored_to = context.storage_read(arrival_slot + 2);
        let pop_silver = context.storage_read(arrival_slot + 3);
        let stored_pop_arriving = unpack_u64_high(pop_silver);
        assert_eq(stored_player, player);
        assert_eq(stored_from, from_location_id);
        assert_eq(stored_to, to_location_id);
        assert(stored_pop_arriving > 0);

        let planet_slot =
            derive_storage_slot_in_map(DarkForest::storage_layout().planets.slot, from_location_id);
        let stored_population = context.storage_read(planet_slot + 3);
        let post_last_updated = context.storage_read(planet_slot + 12);
        let time_elapsed = (post_last_updated as u128) - (pre_last_updated as u128);
        let refreshed_population = expected_population_after_time(
            pre_population,
            pre_pop_cap,
            pre_pop_growth,
            time_elapsed,
            pre_planet_type as u8,
            pre_pausers as u8,
        );
        let expected_remaining = if refreshed_population > MOVE_POP_MOVED {
            refreshed_population - MOVE_POP_MOVED
        } else {
            0
        };
        assert(stored_population < pre_population);
        assert_eq(stored_population, expected_remaining);

        let arrival_list_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_arrivals.slot,
            to_location_id,
        );
        let packed = context.storage_read(arrival_list_slot);
        let stored_arrival_id = unpack_u64_low(packed);
        assert_eq(stored_arrival_id, 1);
    });
}

#[test(should_fail)]
unconstrained fn test_fail_move_radius_above_world() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            INIT_X,
            INIT_Y,
            MOVE_X_2,
            MOVE_Y_2,
            utils::WORLD_RADIUS + 1,
            MOVE_DIST_MAX,
            MOVE_POP_MOVED,
            0,
            0,
            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );
}

#[test(should_fail)]
unconstrained fn test_fail_move_too_much_population() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,

        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            INIT_X,
            INIT_Y,
            MOVE_X_2,
            MOVE_Y_2,
            utils::WORLD_RADIUS,
            MOVE_DIST_MAX,
            HOME_PLANET_POPULATION + 1000,
            0,
            0,
            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );
}

#[test]
unconstrained fn test_apply_arrival_captures_unowned_planet() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            INIT_X,
            INIT_Y,
            CAPTURE_X_2,
            CAPTURE_Y_2,
            utils::WORLD_RADIUS,
            CAPTURE_DIST_MAX,
            MOVE_POP_MOVED,
            0,
            0,
            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).resolve_arrival(1)
    );

    let to_location_id = expected_location_id(CAPTURE_X_2, CAPTURE_Y_2);
    env.public_context_at(contract_address, |context| {
        let planet_slot =
            derive_storage_slot_in_map(DarkForest::storage_layout().planets.slot, to_location_id);
        let stored_owner = context.storage_read(planet_slot + 1);
        let stored_population = context.storage_read(planet_slot + 3);
        assert_eq(stored_owner, player);
        assert(stored_population > 0);
    });
}

#[test(should_fail)]
unconstrained fn test_fail_arrival_too_early() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            INIT_X,
            INIT_Y,
            INIT_X,
            INIT_Y + 2,
            utils::WORLD_RADIUS,
            2,
            MOVE_POP_MOVED,
            0,
            0,
            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).resolve_arrival(1)
    );
}

#[test(should_fail)]
unconstrained fn test_fail_reveal_duplicate() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            REVEAL_X,
            REVEAL_Y,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );
    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            REVEAL_X,
            REVEAL_Y,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );
}

#[test(should_fail)]
unconstrained fn test_fail_reveal_cooldown() {
    let (mut env, contract_address, _) = utils::setup_with_cooldown(1000);
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            REVEAL_X,
            REVEAL_Y,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );
    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            REVEAL_X_2,
            REVEAL_Y_2,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );
}

#[test]
unconstrained fn test_upgrade_planet_success() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),

            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let home_location_id = expected_location_id(INIT_X, INIT_Y);
    let mut home_range: u64 = 0;
    let mut home_pop_cap: u64 = 0;
    let mut home_speed: u64 = 0;
    let home_range_ref = &mut home_range;
    let home_pop_cap_ref = &mut home_pop_cap;
    let home_speed_ref = &mut home_speed;

    env.public_context_at(contract_address, |context| {
        let planet_slot =
            derive_storage_slot_in_map(DarkForest::storage_layout().planets.slot, home_location_id);
        *home_pop_cap_ref = context.storage_read(planet_slot + 4);
        *home_range_ref = context.storage_read(planet_slot + 9);
        *home_speed_ref = context.storage_read(planet_slot + 10);
    });

    let mut planet_found = false;
    let mut planet_x: Field = 0;
    let mut planet_y: Field = 0;
    let mut planet_dist: u64 = 0;
    let mut planet_location_id: Field = 0;
    let mut planet_silver_cap: u64 = 0;
    let pop_moved: u64 = HOME_PLANET_POPULATION / 4;

    for dx in 0..(SEARCH_MAX_DIST + 1) {
        for dy in 0..(SEARCH_MAX_DIST + 1) {
            let is_home = (dx == 0) & (dy == 0);
            if (!planet_found) & !is_home {
                let dist_sq = (dx as u128) * (dx as u128) + (dy as u128) * (dy as u128);
                let dist = ceil_sqrt_u128(dist_sq, SEARCH_MAX_DIST);
                let x = INIT_X + (dx as Field);
                let y = dy as Field;
                let perlin = expected_perlin(x, y);
                let location_id = expected_location_id(x, y);
                let space_type = expected_space_type(perlin);
                let level = expected_planet_level(location_id, space_type);
                let planet_type = expected_planet_type(location_id, space_type, level);
                if (level > 0) & (planet_type == PLANET_TYPE_PLANET) {
                    env.call_private(
                        player,
                        DarkForest::at(contract_address).reveal_location(
                            x,
                            y,
                            utils::PLANETHASH_KEY,
                            utils::SPACETYPE_KEY,
                            utils::PERLIN_LENGTH_SCALE,
                            utils::PERLIN_MIRROR_X,
                            utils::PERLIN_MIRROR_Y,
                            utils::spacetype_config_hash(),
                            utils::MAX_LOCATION_ID,
                        )
                    );

                    let mut stored_population: u64 = 0;
                    let mut stored_defense: u64 = 0;
                    let mut stored_silver_cap: u64 = 0;
                    let pop_ref = &mut stored_population;
                    let def_ref = &mut stored_defense;
                    let silver_cap_ref = &mut stored_silver_cap;

                    env.public_context_at(contract_address, |context| {
                        let planet_slot = derive_storage_slot_in_map(
                            DarkForest::storage_layout().planets.slot,
                            location_id,
                        );
                        *pop_ref = context.storage_read(planet_slot + 3);
                        *def_ref = context.storage_read(planet_slot + 11);
                        *silver_cap_ref = context.storage_read(planet_slot + 7);
                    });

                    let req_planet =
                        ((stored_population as u128) * (stored_defense as u128)) / 100u128;
                    let pop_arriving =
                        decayed_population(pop_moved, dist, home_range, home_pop_cap);
                    if (pop_arriving as u128) >= req_planet {
                        planet_found = true;
                        planet_x = x;
                        planet_y = y;
                        planet_dist = dist;
                        planet_location_id = location_id;
                        planet_silver_cap = stored_silver_cap;
                    }
                }
            }
        }
    }
    assert(planet_found);

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            INIT_X,
            INIT_Y,
            planet_x,
            planet_y,
            utils::WORLD_RADIUS,
            planet_dist,
            pop_moved,
            0,
            0,
            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );

    let mut travel_time_planet = (planet_dist * 100) / home_speed;
    if travel_time_planet == 0 {
        travel_time_planet = 1;
    }
    let mut advance_planet = travel_time_planet - 1;
    assert(advance_planet <= MAX_ADVANCE_BLOCKS);
    for i in 0..MAX_ADVANCE_BLOCKS {
        if (i as u64) < advance_planet {
            env.call_private(
                player,
                DarkForest::at(contract_address).reveal_location(
                    (6000 + (i as u64)) as Field,
                    0,
                    utils::PLANETHASH_KEY,
                    utils::SPACETYPE_KEY,
                    utils::PERLIN_LENGTH_SCALE,
                    utils::PERLIN_MIRROR_X,
                    utils::PERLIN_MIRROR_Y,
                    utils::spacetype_config_hash(),
                    utils::MAX_LOCATION_ID,
                )
            );
        }
    }
    env.call_private(player, DarkForest::at(contract_address).resolve_arrival(1));

    let mut pre_pop_cap: u64 = 0;
    let mut pre_pop_growth: u64 = 0;
    let mut pre_range: u64 = 0;
    let mut pre_speed: u64 = 0;
    let mut pre_defense: u64 = 0;
    let mut pre_silver: u64 = 0;
    let mut pre_upgrade_state0: u8 = 0;
    let pre_pop_cap_ref = &mut pre_pop_cap;
    let pre_pop_growth_ref = &mut pre_pop_growth;
    let pre_range_ref = &mut pre_range;
    let pre_speed_ref = &mut pre_speed;
    let pre_defense_ref = &mut pre_defense;
    let pre_silver_ref = &mut pre_silver;
    let pre_upgrade_state0_ref = &mut pre_upgrade_state0;

    env.public_context_at(contract_address, |context| {
        let planet_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            planet_location_id,
        );
        *pre_pop_cap_ref = context.storage_read(planet_slot + 4);
        *pre_pop_growth_ref = context.storage_read(planet_slot + 5);
        *pre_range_ref = context.storage_read(planet_slot + 9);
        *pre_speed_ref = context.storage_read(planet_slot + 10);
        *pre_defense_ref = context.storage_read(planet_slot + 11);
        *pre_silver_ref = context.storage_read(planet_slot + 6);
        *pre_upgrade_state0_ref = context.storage_read(planet_slot + 17);
    });

    let upgrade_cost = ((planet_silver_cap as u128) * 20u128) / 100u128;
    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_silver(
            planet_location_id,
            upgrade_cost as u64,
        )
    );
    pre_silver = upgrade_cost as u64;

    env.call_private(
        player,
        DarkForest::at(contract_address).upgrade_planet(
            planet_location_id,
            UPGRADE_BRANCH_DEFENSE,
        )
    );

    env.public_context_at(contract_address, |context| {
        let planet_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            planet_location_id,
        );
        let stored_pop_cap = context.storage_read(planet_slot + 4);
        let stored_pop_growth = context.storage_read(planet_slot + 5);
        let stored_range = context.storage_read(planet_slot + 9);
        let stored_speed = context.storage_read(planet_slot + 10);
        let stored_defense = context.storage_read(planet_slot + 11);
        let stored_silver = context.storage_read(planet_slot + 6);
        let stored_upgrade_state0 = context.storage_read(planet_slot + 17);

        assert_eq(
            stored_pop_cap,
            ((pre_pop_cap as u128) * 120u128 / 100u128) as u64
        );
        assert_eq(
            stored_pop_growth,
            ((pre_pop_growth as u128) * 120u128 / 100u128) as u64
        );
        assert_eq(stored_range, pre_range);
        assert_eq(stored_speed, pre_speed);
        assert_eq(
            stored_defense,
            ((pre_defense as u128) * 120u128 / 100u128) as u64
        );
        assert_eq(
            stored_silver,
            (pre_silver as u128 - upgrade_cost) as u64
        );
        assert_eq(stored_upgrade_state0, (pre_upgrade_state0 + 1));
    });
}

#[test(should_fail)]
unconstrained fn test_fail_upgrade_invalid_branch() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,

        )
    );

    let location_id = expected_location_id(INIT_X, INIT_Y);
    env.call_private(
        player,
        DarkForest::at(contract_address).upgrade_planet(
            location_id,
            3,
        )
    );
}

#[test]
unconstrained fn test_prospect_planet_success() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let mut ruins_found = false;
    let mut ruins_location_id: Field = 0;

    for dx in 0..(SEARCH_MAX_DIST_RUINS + 1) {
        for dy in 0..(SEARCH_MAX_DIST_RUINS + 1) {
            let is_home = (dx == 0) & (dy == 0);
            if (!ruins_found) & !is_home {
                let x = INIT_X + (dx as Field);
                let y = dy as Field;
                let perlin = expected_perlin(x, y);
                let location_id = expected_location_id(x, y);
                let space_type = expected_space_type(perlin);
                let level = expected_planet_level(location_id, space_type);
                let planet_type = expected_planet_type(location_id, space_type, level);
                if planet_type == PLANET_TYPE_RUINS {
                    env.call_private(
                        player,
                        DarkForest::at(contract_address).reveal_location(
                            x,
                            y,
                            utils::PLANETHASH_KEY,
                            utils::SPACETYPE_KEY,
                            utils::PERLIN_LENGTH_SCALE,
                            utils::PERLIN_MIRROR_X,
                            utils::PERLIN_MIRROR_Y,
                            utils::spacetype_config_hash(),
                            utils::MAX_LOCATION_ID,
                        )
                    );

                    ruins_found = true;
                    ruins_location_id = location_id;
                }
            }
        }
    }
    assert(ruins_found);

    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_owner(
            ruins_location_id,
            player,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).prospect_planet(ruins_location_id)
    );

    let mut stored_tried: u8 = 0;
    let mut stored_prospected: u32 = 0;
    let tried_ref = &mut stored_tried;
    let prospected_ref = &mut stored_prospected;
    env.public_context_at(contract_address, |context| {
        let state_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_artifact_state.slot,
            ruins_location_id,
        );
        *tried_ref = context.storage_read(state_slot);
        *prospected_ref = context.storage_read(state_slot + 1);
    });

    assert_eq(stored_tried, 0);
    assert(stored_prospected > 0);
}

#[test(should_fail)]
unconstrained fn test_fail_prospect_non_ruins() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let location_id = expected_location_id(INIT_X, INIT_Y);
    env.call_private(
        player,
        DarkForest::at(contract_address).prospect_planet(location_id)
    );
}

#[test]
unconstrained fn test_find_artifact_success() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let mut ruins_found = false;
    let mut ruins_location_id: Field = 0;
    let mut ruins_x: Field = 0;
    let mut ruins_y: Field = 0;

    for dx in 0..(SEARCH_MAX_DIST_RUINS + 1) {
        for dy in 0..(SEARCH_MAX_DIST_RUINS + 1) {
            let is_home = (dx == 0) & (dy == 0);
            if (!ruins_found) & !is_home {
                let x = INIT_X + (dx as Field);
                let y = dy as Field;
                let perlin = expected_perlin(x, y);
                let location_id = expected_location_id(x, y);
                let space_type = expected_space_type(perlin);
                let level = expected_planet_level(location_id, space_type);
                let planet_type = expected_planet_type(location_id, space_type, level);
                if planet_type == PLANET_TYPE_RUINS {
                    ruins_found = true;
                    ruins_location_id = location_id;
                    ruins_x = x;
                    ruins_y = y;
                }
            }
        }
    }
    assert(ruins_found);

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            ruins_x,
            ruins_y,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_owner(
            ruins_location_id,
            player,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).prospect_planet(ruins_location_id)
    );

    let biomebase = expected_biomebase(ruins_x, ruins_y);
    env.call_private(
        player,
        DarkForest::at(contract_address).find_artifact(
            ruins_x,
            ruins_y,
            biomebase,
            utils::PLANETHASH_KEY,
            utils::BIOMEBASE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::biome_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    let mut stored_tried: u8 = 0;
    let mut stored_prospected: u32 = 0;
    let mut stored_artifact_id: Field = 0;
    let tried_ref = &mut stored_tried;
    let prospected_ref = &mut stored_prospected;
    let artifact_id_ref = &mut stored_artifact_id;
    env.public_context_at(contract_address, |context| {
        let state_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_artifact_state.slot,
            ruins_location_id,
        );
        *tried_ref = context.storage_read(state_slot);
        *prospected_ref = context.storage_read(state_slot + 1);

        let artifact_list_slot = derive_storage_slot_in_map(

            DarkForest::storage_layout().planet_artifacts.slot,
            ruins_location_id,
        );
        *artifact_id_ref = context.storage_read(artifact_list_slot);
    });

    assert_eq(stored_tried, 1);
    assert(stored_prospected > 0);
    assert(stored_artifact_id != 0);

    let expected_seed = expected_artifact_seed(
        ruins_location_id,
        contract_address.to_field(),
        stored_prospected,
    );
    assert_eq(stored_artifact_id, expected_seed);

    let mut stored_location: Field = 0;
    let mut nft_contract = AztecAddress::zero();
    let location_ref = &mut stored_location;
    let nft_contract_ref = &mut nft_contract;
    env.public_context_at(contract_address, |context| {
        let location_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().artifact_locations.slot,
            expected_seed,
        );
        *location_ref = context.storage_read(location_slot);
        *nft_contract_ref = context.storage_read(DarkForest::storage_layout().nft_contract.slot);
    });

    assert_eq(stored_location, ruins_location_id);

    let mut stored_owner = AztecAddress::zero();
    let owner_ref = &mut stored_owner;
    env.public_context_at(nft_contract, |context| {
        let owner_slot = derive_storage_slot_in_map(
            NFT::storage_layout().public_owners.slot,
            expected_seed,
        );
        *owner_ref = context.storage_read(owner_slot);
    });
    assert_eq(stored_owner, contract_address);

    let perlin = expected_perlin(ruins_x, ruins_y);
    let space_type = expected_space_type(perlin);
    let level = expected_planet_level(ruins_location_id, space_type);
    let biome = expected_biome(space_type, biomebase);
    let (expected_type, bonus) = expected_artifact_type_and_bonus(expected_seed, biome);
    let level_with_bonus = (level as u16 + bonus as u16) as u8;
    let expected_rarity = expected_artifact_rarity(level_with_bonus);

    let mut stored_initialized: u8 = 0;
    let mut stored_id: Field = 0;
    let mut stored_planet: Field = 0;
    let mut stored_rarity: u8 = 0;
    let mut stored_biome: u8 = 0;
    let mut stored_discoverer = player;
    let mut stored_type: u8 = 0;
    let init_ref = &mut stored_initialized;
    let id_ref = &mut stored_id;
    let planet_ref = &mut stored_planet;
    let rarity_ref = &mut stored_rarity;
    let biome_ref = &mut stored_biome;
    let discoverer_ref = &mut stored_discoverer;
    let type_ref = &mut stored_type;
    env.public_context_at(contract_address, |context| {
        let artifact_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().artifacts.slot,
            expected_seed,
        );
        *init_ref = context.storage_read(artifact_slot);
        *id_ref = context.storage_read(artifact_slot + 1);
        *planet_ref = context.storage_read(artifact_slot + 2);
        *rarity_ref = context.storage_read(artifact_slot + 3);
        *biome_ref = context.storage_read(artifact_slot + 4);
        *discoverer_ref = context.storage_read(artifact_slot + 5);
        *type_ref = context.storage_read(artifact_slot + 6);
    });

    assert_eq(stored_initialized, 1);
    assert_eq(stored_id, expected_seed);
    assert_eq(stored_planet, ruins_location_id);
    assert_eq(stored_rarity, expected_rarity);
    assert_eq(stored_biome, biome);
    assert_eq(stored_discoverer, player);
    assert_eq(stored_type, expected_type);
}

#[test(should_fail)]
unconstrained fn test_fail_find_artifact_not_prospected() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let mut ruins_found = false;
    let mut ruins_location_id: Field = 0;
    let mut ruins_x: Field = 0;
    let mut ruins_y: Field = 0;

    for dx in 0..(SEARCH_MAX_DIST_RUINS + 1) {
        for dy in 0..(SEARCH_MAX_DIST_RUINS + 1) {
            let is_home = (dx == 0) & (dy == 0);
            if (!ruins_found) & !is_home {
                let x = INIT_X + (dx as Field);
                let y = dy as Field;
                let perlin = expected_perlin(x, y);
                let location_id = expected_location_id(x, y);
                let space_type = expected_space_type(perlin);
                let level = expected_planet_level(location_id, space_type);
                let planet_type = expected_planet_type(location_id, space_type, level);
                if planet_type == PLANET_TYPE_RUINS {
                    ruins_found = true;
                    ruins_location_id = location_id;
                    ruins_x = x;
                    ruins_y = y;
                }
            }
        }
    }
    assert(ruins_found);

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            ruins_x,
            ruins_y,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_owner(
            ruins_location_id,
            player,
        )
    );

    let biomebase = expected_biomebase(ruins_x, ruins_y);
    env.call_private(
        player,
        DarkForest::at(contract_address).find_artifact(
            ruins_x,
            ruins_y,
            biomebase,
            utils::PLANETHASH_KEY,
            utils::BIOMEBASE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::biome_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );
}

#[test(should_fail)]
unconstrained fn test_fail_find_artifact_already_tried() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let mut ruins_found = false;
    let mut ruins_location_id: Field = 0;
    let mut ruins_x: Field = 0;
    let mut ruins_y: Field = 0;

    for dx in 0..(SEARCH_MAX_DIST_RUINS + 1) {
        for dy in 0..(SEARCH_MAX_DIST_RUINS + 1) {
            let is_home = (dx == 0) & (dy == 0);
            if (!ruins_found) & !is_home {
                let x = INIT_X + (dx as Field);
                let y = dy as Field;
                let perlin = expected_perlin(x, y);
                let location_id = expected_location_id(x, y);
                let space_type = expected_space_type(perlin);
                let level = expected_planet_level(location_id, space_type);
                let planet_type = expected_planet_type(location_id, space_type, level);
                if planet_type == PLANET_TYPE_RUINS {
                    ruins_found = true;
                    ruins_location_id = location_id;
                    ruins_x = x;
                    ruins_y = y;
                }
            }
        }
    }
    assert(ruins_found);

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            ruins_x,
            ruins_y,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    env.call_private(
        admin,

        DarkForest::at(contract_address).admin_set_planet_owner(
            ruins_location_id,
            player,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).prospect_planet(ruins_location_id)
    );

    let biomebase = expected_biomebase(ruins_x, ruins_y);
    env.call_private(
        player,
        DarkForest::at(contract_address).find_artifact(
            ruins_x,
            ruins_y,
            biomebase,
            utils::PLANETHASH_KEY,
            utils::BIOMEBASE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::biome_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).find_artifact(
            ruins_x,
            ruins_y,
            biomebase,
            utils::PLANETHASH_KEY,
            utils::BIOMEBASE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::biome_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );
}

#[test(should_fail)]
unconstrained fn test_fail_find_artifact_non_ruins() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let biomebase = expected_biomebase(INIT_X, INIT_Y);
    env.call_private(
        player,
        DarkForest::at(contract_address).find_artifact(
            INIT_X,
            INIT_Y,
            biomebase,
            utils::PLANETHASH_KEY,
            utils::BIOMEBASE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::biome_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );
}

#[test]
unconstrained fn test_spacetime_rip_withdraw_deposit_roundtrip() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let mut ruins_found = false;
    let mut ruins_location_id: Field = 0;
    let mut ruins_x: Field = 0;
    let mut ruins_y: Field = 0;

    for dx in 0..(SEARCH_MAX_DIST_RUINS + 1) {
        for dy in 0..(SEARCH_MAX_DIST_RUINS + 1) {
            let is_home = (dx == 0) & (dy == 0);
            if (!ruins_found) & !is_home {
                let x = INIT_X + (dx as Field);
                let y = dy as Field;
                let perlin = expected_perlin(x, y);
                let location_id = expected_location_id(x, y);
                let space_type = expected_space_type(perlin);
                let level = expected_planet_level(location_id, space_type);
                let planet_type = expected_planet_type(location_id, space_type, level);
                if planet_type == PLANET_TYPE_RUINS {
                    ruins_found = true;
                    ruins_location_id = location_id;
                    ruins_x = x;
                    ruins_y = y;
                }
            }
        }
    }
    assert(ruins_found);

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            ruins_x,
            ruins_y,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_owner(
            ruins_location_id,
            player,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).prospect_planet(ruins_location_id)
    );

    let biomebase = expected_biomebase(ruins_x, ruins_y);
    env.call_private(
        player,
        DarkForest::at(contract_address).find_artifact(
            ruins_x,
            ruins_y,
            biomebase,
            utils::PLANETHASH_KEY,
            utils::BIOMEBASE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::biome_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    let mut artifact_id: Field = 0;
    let artifact_id_ref = &mut artifact_id;
    env.public_context_at(contract_address, |context| {
        let artifact_list_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_artifacts.slot,
            ruins_location_id,
        );
        *artifact_id_ref = context.storage_read(artifact_list_slot);
    });
    assert(artifact_id != 0);

    let mut nft_contract = AztecAddress::zero();
    let nft_contract_ref = &mut nft_contract;
    env.public_context_at(contract_address, |context| {
        let nft_slot = DarkForest::storage_layout().nft_contract.slot;
        *nft_contract_ref = context.storage_read(nft_slot);
    });

    let mut nft_owner_after_find = AztecAddress::zero();
    let nft_owner_after_find_ref = &mut nft_owner_after_find;
    env.public_context_at(nft_contract, |context| {
        let owner_slot = derive_storage_slot_in_map(
            NFT::storage_layout().public_owners.slot,
            artifact_id,
        );
        *nft_owner_after_find_ref = context.storage_read(owner_slot);
    });
    assert_eq(nft_owner_after_find, contract_address);

    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_type_and_level(
            ruins_location_id,
            PLANET_TYPE_TRADING_POST,
            9,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).trade_artifact(
            ruins_location_id,
            artifact_id,
            true,
        )
    );

    let mut stored_location: Field = 0;
    let mut stored_slot0: Field = 0;
    let location_ref = &mut stored_location;
    let slot0_ref = &mut stored_slot0;
    env.public_context_at(contract_address, |context| {
        let location_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().artifact_locations.slot,
            artifact_id,
        );
        *location_ref = context.storage_read(location_slot);
        let list_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_artifacts.slot,
            ruins_location_id,
        );
        *slot0_ref = context.storage_read(list_slot);
    });

    assert_eq(stored_location, 0);

    assert_eq(stored_slot0, 0);

    let mut nft_owner_after_withdraw = AztecAddress::zero();
    let nft_owner_after_withdraw_ref = &mut nft_owner_after_withdraw;
    env.public_context_at(nft_contract, |context| {
        let owner_slot = derive_storage_slot_in_map(
            NFT::storage_layout().public_owners.slot,
            artifact_id,
        );
        *nft_owner_after_withdraw_ref = context.storage_read(owner_slot);
    });
    assert_eq(nft_owner_after_withdraw, player);

    env.call_private(
        player,
        DarkForest::at(contract_address).trade_artifact(
            ruins_location_id,
            artifact_id,
            false,
        )
    );

    let mut stored_location_after_deposit: Field = 0;
    let mut stored_slot0_after_deposit: Field = 0;
    let location_dep_ref = &mut stored_location_after_deposit;
    let slot0_dep_ref = &mut stored_slot0_after_deposit;
    env.public_context_at(contract_address, |context| {
        let location_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().artifact_locations.slot,
            artifact_id,
        );
        *location_dep_ref = context.storage_read(location_slot);
        let list_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_artifacts.slot,
            ruins_location_id,
        );
        *slot0_dep_ref = context.storage_read(list_slot);
    });

    assert_eq(stored_location_after_deposit, ruins_location_id);
    assert_eq(stored_slot0_after_deposit, artifact_id);

    let mut nft_owner_after_deposit = AztecAddress::zero();
    let nft_owner_after_deposit_ref = &mut nft_owner_after_deposit;
    env.public_context_at(nft_contract, |context| {
        let owner_slot = derive_storage_slot_in_map(
            NFT::storage_layout().public_owners.slot,
            artifact_id,
        );
        *nft_owner_after_deposit_ref = context.storage_read(owner_slot);
    });
    assert_eq(nft_owner_after_deposit, contract_address);

    env.call_private(
        player,
        DarkForest::at(contract_address).trade_artifact(
            ruins_location_id,
            artifact_id,
            true,
        )
    );

    let mut stored_location_final: Field = 0;
    let mut stored_slot0_final: Field = 0;
    let location_final_ref = &mut stored_location_final;
    let slot0_final_ref = &mut stored_slot0_final;
    env.public_context_at(contract_address, |context| {
        let location_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().artifact_locations.slot,
            artifact_id,
        );
        *location_final_ref = context.storage_read(location_slot);
        let list_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_artifacts.slot,
            ruins_location_id,
        );
        *slot0_final_ref = context.storage_read(list_slot);
    });

    assert_eq(stored_location_final, 0);
    assert_eq(stored_slot0_final, 0);

    let mut nft_owner_final = AztecAddress::zero();
    let nft_owner_final_ref = &mut nft_owner_final;
    env.public_context_at(nft_contract, |context| {
        let owner_slot = derive_storage_slot_in_map(
            NFT::storage_layout().public_owners.slot,
            artifact_id,
        );
        *nft_owner_final_ref = context.storage_read(owner_slot);
    });
    assert_eq(nft_owner_final, player);
}

#[test(should_fail)]
unconstrained fn test_fail_withdraw_not_planet_owner() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();
    let other = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let location_id = expected_location_id(INIT_X, INIT_Y);
    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_type_and_level(
            location_id,
            PLANET_TYPE_TRADING_POST,
            9,
        )
    );

    let artifact_id: Field = 9100;
    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_create_artifact_on_planet(
            location_id,
            artifact_id,
            ARTIFACT_TYPE_MONOLITH,
            ARTIFACT_RARITY_COMMON,
            BIOME_OCEAN,
            contract_address,
        )
    );

    env.call_private(
        other,
        DarkForest::at(contract_address).trade_artifact(
            location_id,
            artifact_id,
            true,
        )
    );
}

#[test(should_fail)]
unconstrained fn test_fail_deposit_not_artifact_owner() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();
    let other = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let location_id = expected_location_id(INIT_X, INIT_Y);
    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_type_and_level(
            location_id,
            PLANET_TYPE_TRADING_POST,
            9,
        )
    );

    let artifact_id: Field = 9101;
    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_create_artifact_on_planet(
            location_id,
            artifact_id,
            ARTIFACT_TYPE_MONOLITH,
            ARTIFACT_RARITY_COMMON,
            BIOME_OCEAN,
            contract_address,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).trade_artifact(
            location_id,
            artifact_id,
            true,
        )
    );

    env.call_private(
        other,
        DarkForest::at(contract_address).trade_artifact(
            location_id,
            artifact_id,
            false,
        )
    );
}

#[test(should_fail)]
unconstrained fn test_fail_withdraw_not_trading_post() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let mut ruins_found = false;
    let mut ruins_location_id: Field = 0;
    let mut ruins_x: Field = 0;
    let mut ruins_y: Field = 0;


    for dx in 0..(SEARCH_MAX_DIST_RUINS + 1) {
        for dy in 0..(SEARCH_MAX_DIST_RUINS + 1) {
            let is_home = (dx == 0) & (dy == 0);
            if (!ruins_found) & !is_home {
                let x = INIT_X + (dx as Field);
                let y = dy as Field;
                let perlin = expected_perlin(x, y);
                let location_id = expected_location_id(x, y);
                let space_type = expected_space_type(perlin);
                let level = expected_planet_level(location_id, space_type);
                let planet_type = expected_planet_type(location_id, space_type, level);
                if planet_type == PLANET_TYPE_RUINS {
                    ruins_found = true;
                    ruins_location_id = location_id;
                    ruins_x = x;
                    ruins_y = y;
                }
            }
        }
    }
    assert(ruins_found);

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            ruins_x,
            ruins_y,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_owner(
            ruins_location_id,
            player,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).prospect_planet(ruins_location_id)
    );

    let biomebase = expected_biomebase(ruins_x, ruins_y);
    env.call_private(
        player,
        DarkForest::at(contract_address).find_artifact(
            ruins_x,
            ruins_y,
            biomebase,
            utils::PLANETHASH_KEY,
            utils::BIOMEBASE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::biome_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    let mut artifact_id: Field = 0;
    let artifact_id_ref = &mut artifact_id;
    env.public_context_at(contract_address, |context| {
        let artifact_list_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_artifacts.slot,
            ruins_location_id,
        );
        *artifact_id_ref = context.storage_read(artifact_list_slot);
    });
    assert(artifact_id != 0);

    env.call_private(
        player,
        DarkForest::at(contract_address).trade_artifact(
            ruins_location_id,
            artifact_id,
            true,
        )
    );
}

#[test]
unconstrained fn test_activate_wormhole_and_move_speedup() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            MOVE_X_2,
            MOVE_Y_2,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    let home_location_id = expected_location_id(INIT_X, INIT_Y);
    let target_location_id = expected_location_id(MOVE_X_2, MOVE_Y_2);

    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_owner(
            target_location_id,
            player,
        )
    );

    let artifact_id: Field = 9001;
    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_create_artifact_on_planet(
            home_location_id,
            artifact_id,
            ARTIFACT_TYPE_WORMHOLE,
            ARTIFACT_RARITY_RARE,
            BIOME_OCEAN,
            contract_address,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).set_artifact_activation(
            home_location_id,
            artifact_id,
            target_location_id,
            true,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            INIT_X,
            INIT_Y,
            MOVE_X_2,
            MOVE_Y_2,
            utils::WORLD_RADIUS,
            MOVE_DIST_MAX,
            MOVE_POP_MOVED,
            0,
            0,
            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );

    let mut arrival_type: u8 = 0;
    let mut departure_block: u32 = 0;
    let mut arrival_block: u32 = 0;
    let mut speed: u64 = 0;
    let arrival_type_ref = &mut arrival_type;
    let departure_block_ref = &mut departure_block;
    let arrival_block_ref = &mut arrival_block;
    let speed_ref = &mut speed;
    env.public_context_at(contract_address, |context| {
        let arrival_slot =
            derive_storage_slot_in_map(DarkForest::storage_layout().arrivals.slot, 1);
        let meta = context.storage_read(arrival_slot + 4);
        let (depart, arrive, arrival_type) = unpack_arrival_meta(meta);
        *arrival_type_ref = arrival_type;
        *departure_block_ref = depart;
        *arrival_block_ref = arrive;

        let planet_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            home_location_id,
        );
        *speed_ref = context.storage_read(planet_slot + 10);
    });

    let modifier = WORMHOLE_SPEED_MODIFIERS[ARTIFACT_RARITY_RARE as u32];
    let mut expected_travel = (MOVE_DIST_MAX * 100) / modifier;
    expected_travel = expected_travel / speed;
    if expected_travel == 0 {
        expected_travel = 1;
    }

    assert_eq(arrival_type, ARRIVAL_TYPE_WORMHOLE);
    assert_eq((arrival_block - departure_block) as u64, expected_travel);
}

#[test]
unconstrained fn test_wormhole_arrival_skips_combat_on_enemy() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();
    let defender = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    env.call_private(
        player,

        DarkForest::at(contract_address).reveal_location(
            CAPTURE_X_2,
            CAPTURE_Y_2,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    let home_location_id = expected_location_id(INIT_X, INIT_Y);
    let target_location_id = expected_location_id(CAPTURE_X_2, CAPTURE_Y_2);

    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_owner(
            target_location_id,
            player,
        )
    );

    let artifact_id: Field = 9002;
    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_create_artifact_on_planet(
            home_location_id,
            artifact_id,
            ARTIFACT_TYPE_WORMHOLE,
            ARTIFACT_RARITY_RARE,
            BIOME_OCEAN,
            contract_address,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).set_artifact_activation(
            home_location_id,
            artifact_id,
            target_location_id,
            true,
        )
    );

    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_owner(
            target_location_id,
            defender,
        )
    );

    let mut initial_owner = AztecAddress::zero();
    let mut initial_population: u64 = 0;
    let initial_owner_ref = &mut initial_owner;
    let initial_population_ref = &mut initial_population;
    env.public_context_at(contract_address, |context| {
        let planet_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            target_location_id,
        );
        *initial_owner_ref = context.storage_read(planet_slot + 1);
        *initial_population_ref = context.storage_read(planet_slot + 3);
    });
    assert_eq(initial_owner, defender);

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            INIT_X,
            INIT_Y,
            CAPTURE_X_2,
            CAPTURE_Y_2,
            utils::WORLD_RADIUS,
            CAPTURE_DIST_MAX,
            40000,
            0,
            0,
            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );

    let mut arrival_id: u64 = 0;
    let arrival_id_ref = &mut arrival_id;
    env.public_context_at(contract_address, |context| {
        let arrival_list_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_arrivals.slot,
            target_location_id,
        );
        let packed = context.storage_read(arrival_list_slot);
        *arrival_id_ref = unpack_u64_low(packed);
    });
    assert(arrival_id != 0);

    let mut arrival_type: u8 = 0;
    let arrival_type_ref = &mut arrival_type;
    env.public_context_at(contract_address, |context| {
        let arrival_slot =
            derive_storage_slot_in_map(DarkForest::storage_layout().arrivals.slot, arrival_id);
        let meta = context.storage_read(arrival_slot + 4);
        let (_, _, stored_arrival_type) = unpack_arrival_meta(meta);
        *arrival_type_ref = stored_arrival_type;
    });
    assert_eq(arrival_type, ARRIVAL_TYPE_WORMHOLE);

    // Ensure the destination is enemy-owned at arrival resolution time.
    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_owner(
            target_location_id,
            defender,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).resolve_arrival(arrival_id)
    );

    let mut final_owner = AztecAddress::zero();
    let mut final_population: u64 = 0;
    let final_owner_ref = &mut final_owner;
    let final_population_ref = &mut final_population;
    env.public_context_at(contract_address, |context| {
        let planet_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            target_location_id,
        );
        *final_owner_ref = context.storage_read(planet_slot + 1);
        *final_population_ref = context.storage_read(planet_slot + 3);
    });

    assert_eq(final_owner, defender);
    assert(final_population >= initial_population);
}

#[test]
unconstrained fn test_photoid_auto_deactivate_and_upgrade() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            MOVE_X_2,
            MOVE_Y_2,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    let home_location_id = expected_location_id(INIT_X, INIT_Y);
    let target_location_id = expected_location_id(MOVE_X_2, MOVE_Y_2);

    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_owner(
            target_location_id,
            player,
        )
    );

    let artifact_id: Field = 9002;
    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_create_artifact_on_planet(
            home_location_id,
            artifact_id,
            ARTIFACT_TYPE_PHOTOID_CANNON,
            ARTIFACT_RARITY_COMMON,
            BIOME_DESERT,
            contract_address,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).set_artifact_activation(
            home_location_id,
            artifact_id,
            0,
            true,
        )
    );

    for i in 0..(PHOTOID_ACTIVATION_DELAY_BLOCKS as u64 + 1) {
        env.call_private(
            player,
            DarkForest::at(contract_address).reveal_location(
                (6000 + i) as Field,
                1,
                utils::PLANETHASH_KEY,
                utils::SPACETYPE_KEY,
                utils::PERLIN_LENGTH_SCALE,
                utils::PERLIN_MIRROR_X,
                utils::PERLIN_MIRROR_Y,
                utils::spacetype_config_hash(),
                utils::MAX_LOCATION_ID,
            )
        );
    }

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            INIT_X,
            INIT_Y,
            MOVE_X_2,
            MOVE_Y_2,
            utils::WORLD_RADIUS,
            MOVE_DIST_MAX,
            MOVE_POP_MOVED,
            0,
            0,

            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );

    let mut arrival_type: u8 = 0;
    let mut departure_block: u32 = 0;
    let mut arrival_block: u32 = 0;
    let mut speed: u64 = 0;
    let mut stored_location: Field = 1;
    let mut stored_last_activated: u32 = 0;
    let mut stored_last_deactivated: u32 = 0;
    let arrival_type_ref = &mut arrival_type;
    let departure_block_ref = &mut departure_block;
    let arrival_block_ref = &mut arrival_block;
    let speed_ref = &mut speed;
    let stored_location_ref = &mut stored_location;
    let stored_last_activated_ref = &mut stored_last_activated;
    let stored_last_deactivated_ref = &mut stored_last_deactivated;
    env.public_context_at(contract_address, |context| {
        let arrival_slot =
            derive_storage_slot_in_map(DarkForest::storage_layout().arrivals.slot, 1);
        let meta = context.storage_read(arrival_slot + 4);
        let (depart, arrive, arrival_type) = unpack_arrival_meta(meta);
        *arrival_type_ref = arrival_type;
        *departure_block_ref = depart;
        *arrival_block_ref = arrive;

        let planet_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            home_location_id,
        );
        *speed_ref = context.storage_read(planet_slot + 10);

        let artifact_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().artifacts.slot,
            artifact_id,
        );
        *stored_last_activated_ref = context.storage_read(artifact_slot + 8);
        *stored_last_deactivated_ref = context.storage_read(artifact_slot + 9);

        let location_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().artifact_locations.slot,
            artifact_id,
        );
        *stored_location_ref = context.storage_read(location_slot);
    });

    let speed_multiplier: u64 = 500; // common rarity in v0.6 timeDelayUpgrade
    let speed_upgraded = (speed * speed_multiplier) / 100;
    let mut expected_travel = (MOVE_DIST_MAX * 100) / speed_upgraded;
    if expected_travel == 0 {
        expected_travel = 1;
    }

    assert_eq(arrival_type, ARRIVAL_TYPE_PHOTOID);
    assert_eq((arrival_block - departure_block) as u64, expected_travel);
    assert(stored_last_deactivated >= stored_last_activated);
    assert_eq(stored_location, utils::MAX_LOCATION_ID);
}

#[test]
unconstrained fn test_bloom_filter_burns_and_caps() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let home_location_id = expected_location_id(INIT_X, INIT_Y);
    let artifact_id: Field = 9003;

    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_create_artifact_on_planet(
            home_location_id,
            artifact_id,
            ARTIFACT_TYPE_BLOOM_FILTER,
            ARTIFACT_RARITY_COMMON,
            BIOME_FOREST,
            contract_address,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).set_artifact_activation(
            home_location_id,
            artifact_id,
            0,
            true,
        )
    );

    let mut pop: u64 = 0;
    let mut pop_cap: u64 = 0;
    let mut silver: u64 = 0;
    let mut silver_cap: u64 = 0;
    let mut stored_location: Field = 1;
    let pop_ref = &mut pop;
    let pop_cap_ref = &mut pop_cap;
    let silver_ref = &mut silver;
    let silver_cap_ref = &mut silver_cap;
    let stored_location_ref = &mut stored_location;
    env.public_context_at(contract_address, |context| {
        let planet_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            home_location_id,
        );
        *pop_ref = context.storage_read(planet_slot + 3);
        *pop_cap_ref = context.storage_read(planet_slot + 4);
        *silver_ref = context.storage_read(planet_slot + 6);
        *silver_cap_ref = context.storage_read(planet_slot + 7);

        let location_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().artifact_locations.slot,
            artifact_id,
        );
        *stored_location_ref = context.storage_read(location_slot);
    });

    assert_eq(pop, pop_cap);
    assert_eq(silver, silver_cap);
    assert_eq(stored_location, utils::MAX_LOCATION_ID);

    let mut nft_contract = AztecAddress::zero();
    let nft_contract_ref = &mut nft_contract;
    env.public_context_at(contract_address, |context| {
        let nft_slot = DarkForest::storage_layout().nft_contract.slot;
        *nft_contract_ref = context.storage_read(nft_slot);
    });

    let mut nft_owner = AztecAddress::zero();
    let nft_owner_ref = &mut nft_owner;
    env.public_context_at(nft_contract, |context| {
        let owner_slot = derive_storage_slot_in_map(
            NFT::storage_layout().public_owners.slot,
            artifact_id,
        );
        *nft_owner_ref = context.storage_read(owner_slot);
    });
    assert_eq(nft_owner, contract_address);
}

#[test]
unconstrained fn test_black_domain_destroys_planet() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let home_location_id = expected_location_id(INIT_X, INIT_Y);
    let artifact_id: Field = 9004;

    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_create_artifact_on_planet(
            home_location_id,
            artifact_id,
            ARTIFACT_TYPE_BLACK_DOMAIN,
            ARTIFACT_RARITY_COMMON,
            BIOME_CORRUPTED,
            contract_address,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).set_artifact_activation(
            home_location_id,
            artifact_id,
            0,
            true,
        )
    );

    let mut destroyed: u8 = 0;
    let mut stored_location: Field = 1;
    let destroyed_ref = &mut destroyed;
    let stored_location_ref = &mut stored_location;
    env.public_context_at(contract_address, |context| {
        let destroyed_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_destroyed.slot,
            home_location_id,
        );
        *destroyed_ref = context.storage_read(destroyed_slot);
        let location_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().artifact_locations.slot,
            artifact_id,
        );
        *stored_location_ref = context.storage_read(location_slot);
    });

    assert_eq(destroyed, 1);
    assert_eq(stored_location, utils::MAX_LOCATION_ID);

    let mut nft_contract = AztecAddress::zero();
    let nft_contract_ref = &mut nft_contract;
    env.public_context_at(contract_address, |context| {
        let nft_slot = DarkForest::storage_layout().nft_contract.slot;
        *nft_contract_ref = context.storage_read(nft_slot);
    });

    let mut nft_owner = AztecAddress::zero();
    let nft_owner_ref = &mut nft_owner;
    env.public_context_at(nft_contract, |context| {
        let owner_slot = derive_storage_slot_in_map(
            NFT::storage_layout().public_owners.slot,
            artifact_id,

            artifact_id,
        );
        *nft_owner_ref = context.storage_read(owner_slot);
    });
    assert_eq(nft_owner, contract_address);
}

#[test(should_fail)]
unconstrained fn test_fail_deposit_burned_artifact() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let location_id = expected_location_id(INIT_X, INIT_Y);
    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_type_and_level(
            location_id,
            PLANET_TYPE_TRADING_POST,
            2,
        )
    );

    let artifact_id: Field = 9106;
    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_create_artifact_on_planet(
            location_id,
            artifact_id,
            ARTIFACT_TYPE_BLOOM_FILTER,
            ARTIFACT_RARITY_COMMON,
            BIOME_FOREST,
            contract_address,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).set_artifact_activation(
            location_id,
            artifact_id,
            0,
            true,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).trade_artifact(
            location_id,
            artifact_id,
            false,
        )
    );
}

#[test(should_fail)]
unconstrained fn test_fail_activate_artifact_cooldown() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            MOVE_X_2,
            MOVE_Y_2,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    let home_location_id = expected_location_id(INIT_X, INIT_Y);
    let target_location_id = expected_location_id(MOVE_X_2, MOVE_Y_2);

    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_owner(
            target_location_id,
            player,
        )
    );

    let artifact_id: Field = 9005;
    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_create_artifact_on_planet(
            home_location_id,
            artifact_id,
            ARTIFACT_TYPE_WORMHOLE,
            ARTIFACT_RARITY_COMMON,
            BIOME_OCEAN,
            contract_address,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).set_artifact_activation(
            home_location_id,
            artifact_id,
            target_location_id,
            true,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).set_artifact_activation(
            home_location_id,
            0,
            0,
            false,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).set_artifact_activation(
            home_location_id,
            artifact_id,
            target_location_id,
            true,
        )
    );
}

#[test]
unconstrained fn test_give_space_ships_once() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let home_location_id = expected_location_id(INIT_X, INIT_Y);
    env.call_private(
        player,
        DarkForest::at(contract_address).give_space_ships(home_location_id)
    );

    let ship_mothership = expected_ship_id(home_location_id, ARTIFACT_TYPE_SHIP_MOTHERSHIP);
    let ship_crescent = expected_ship_id(home_location_id, ARTIFACT_TYPE_SHIP_CRESCENT);
    let ship_whale = expected_ship_id(home_location_id, ARTIFACT_TYPE_SHIP_WHALE);
    let ship_gear = expected_ship_id(home_location_id, ARTIFACT_TYPE_SHIP_GEAR);
    let ship_titan = expected_ship_id(home_location_id, ARTIFACT_TYPE_SHIP_TITAN);

    env.public_context_at(contract_address, |context| {
        let list_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_artifacts.slot,
            home_location_id,
        );
        let slot0 = context.storage_read(list_slot);
        let slot1 = context.storage_read(list_slot + 1);
        let slot2 = context.storage_read(list_slot + 2);
        let slot3 = context.storage_read(list_slot + 3);
        let slot4 = context.storage_read(list_slot + 4);
        assert_eq(slot0, ship_mothership);
        assert_eq(slot1, ship_crescent);
        assert_eq(slot2, ship_whale);
        assert_eq(slot3, ship_gear);
        assert_eq(slot4, ship_titan);

        let claimed_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().player_claimed_ships.slot,
            player,
        );
        let claimed = context.storage_read(claimed_slot);
        assert_eq(claimed, 1);
    });
}

#[test(should_fail)]
unconstrained fn test_fail_give_space_ships_twice() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,

            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let home_location_id = expected_location_id(INIT_X, INIT_Y);
    env.call_private(
        player,
        DarkForest::at(contract_address).give_space_ships(home_location_id)
    );
    env.call_private(
        player,
        DarkForest::at(contract_address).give_space_ships(home_location_id)
    );
}

#[test]
unconstrained fn test_spaceship_move_depart_and_arrive_effects() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            MOVE_X_2,
            MOVE_Y_2,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            CAPTURE_X_2,
            CAPTURE_Y_2,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    let home_location_id = expected_location_id(INIT_X, INIT_Y);
    let target_location_id = expected_location_id(MOVE_X_2, MOVE_Y_2);
    let second_location_id = expected_location_id(CAPTURE_X_2, CAPTURE_Y_2);

    env.call_private(
        player,
        DarkForest::at(contract_address).give_space_ships(home_location_id)
    );

    let ship_id = expected_ship_id(home_location_id, ARTIFACT_TYPE_SHIP_MOTHERSHIP);

    let mut base_target_pop_growth: u64 = 0;
    let mut base_second_pop_growth: u64 = 0;
    let mut home_speed: u64 = 0;
    let mut target_speed: u64 = 0;
    let base_target_pop_growth_ref = &mut base_target_pop_growth;
    let base_second_pop_growth_ref = &mut base_second_pop_growth;
    let home_speed_ref = &mut home_speed;
    let target_speed_ref = &mut target_speed;
    env.public_context_at(contract_address, |context| {
        let home_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            home_location_id,
        );
        *home_speed_ref = context.storage_read(home_slot + 10);

        let planet_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            target_location_id,
        );
        *base_target_pop_growth_ref = context.storage_read(planet_slot + 5);
        *target_speed_ref = context.storage_read(planet_slot + 10);
        let second_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            second_location_id,
        );
        *base_second_pop_growth_ref = context.storage_read(second_slot + 5);
    });
    assert(base_target_pop_growth > 0);
    assert(base_second_pop_growth > 0);

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            INIT_X,
            INIT_Y,
            MOVE_X_2,
            MOVE_Y_2,
            utils::WORLD_RADIUS,
            MOVE_DIST_MAX,
            0,
            0,
            ship_id,
            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );

    env.public_context_at(contract_address, |context| {
        let location_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().artifact_locations.slot,
            ship_id,
        );
        let stored_location = context.storage_read(location_slot);
        assert_eq(stored_location, 0);
    });

    let mut travel_time = (MOVE_DIST_MAX * 100) / home_speed;
    if travel_time == 0 {
        travel_time = 1;
    }
    let mut advance_blocks = travel_time - 1;
    assert(advance_blocks <= MAX_ADVANCE_BLOCKS);
    for i in 0..MAX_ADVANCE_BLOCKS {
        if (i as u64) < advance_blocks {
            env.call_private(
                player,
                DarkForest::at(contract_address).reveal_location(
                    (6000 + (i as u64)) as Field,
                    0,
                    utils::PLANETHASH_KEY,
                    utils::SPACETYPE_KEY,
                    utils::PERLIN_LENGTH_SCALE,
                    utils::PERLIN_MIRROR_X,
                    utils::PERLIN_MIRROR_Y,
                    utils::spacetype_config_hash(),
                    utils::MAX_LOCATION_ID,
                )
            );
        }
    }

    env.call_private(
        player,
        DarkForest::at(contract_address).resolve_arrival(1)
    );

    env.public_context_at(contract_address, |context| {
        let location_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().artifact_locations.slot,
            ship_id,
        );
        let stored_location = context.storage_read(location_slot);
        assert_eq(stored_location, target_location_id);
    });

    let mut target_pop_growth: u64 = 0;
    let mut target_doublers: u64 = 0;
    let target_pop_growth_ref = &mut target_pop_growth;
    let target_doublers_ref = &mut target_doublers;
    env.public_context_at(contract_address, |context| {
        let planet_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            target_location_id,
        );
        *target_pop_growth_ref = context.storage_read(planet_slot + 5);
        let doublers_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_energy_gro_doublers.slot,
            target_location_id,
        );
        *target_doublers_ref = context.storage_read(doublers_slot);
    });
    assert_eq(target_pop_growth, base_target_pop_growth * 2);
    assert_eq(target_doublers, 1);

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            MOVE_X_2,
            MOVE_Y_2,
            CAPTURE_X_2,
            CAPTURE_Y_2,
            utils::WORLD_RADIUS,
            MOVE_DIST_MAX,
            0,
            0,
            ship_id,
            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );

    let mut travel_time_second = (MOVE_DIST_MAX * 100) / target_speed;
    if travel_time_second == 0 {
        travel_time_second = 1;
    }
    let mut advance_blocks_second = travel_time_second - 1;
    assert(advance_blocks_second <= MAX_ADVANCE_BLOCKS);
    for i in 0..MAX_ADVANCE_BLOCKS {
        if (i as u64) < advance_blocks_second {
            env.call_private(
                player,
                DarkForest::at(contract_address).reveal_location(
                    (8000 + (i as u64)) as Field,
                    0,
                    utils::PLANETHASH_KEY,
                    utils::SPACETYPE_KEY,
                    utils::PERLIN_LENGTH_SCALE,
                    utils::PERLIN_MIRROR_X,
                    utils::PERLIN_MIRROR_Y,
                    utils::spacetype_config_hash(),
                    utils::MAX_LOCATION_ID,
                )
            );
        }
    }

            );
        }
    }

    env.call_private(
        player,
        DarkForest::at(contract_address).resolve_arrival(2)
    );

    env.public_context_at(contract_address, |context| {
        let location_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().artifact_locations.slot,
            ship_id,
        );
        let stored_location = context.storage_read(location_slot);
        assert_eq(stored_location, second_location_id);
    });

    let mut origin_pop_growth: u64 = 0;
    let mut origin_doublers: u64 = 0;
    let mut second_pop_growth: u64 = 0;
    let mut second_doublers: u64 = 0;
    let origin_pop_growth_ref = &mut origin_pop_growth;
    let origin_doublers_ref = &mut origin_doublers;
    let second_pop_growth_ref = &mut second_pop_growth;
    let second_doublers_ref = &mut second_doublers;
    env.public_context_at(contract_address, |context| {
        let origin_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            target_location_id,
        );
        *origin_pop_growth_ref = context.storage_read(origin_slot + 5);
        let origin_doublers_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_energy_gro_doublers.slot,
            target_location_id,
        );
        *origin_doublers_ref = context.storage_read(origin_doublers_slot);

        let second_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            second_location_id,
        );
        *second_pop_growth_ref = context.storage_read(second_slot + 5);
        let second_doublers_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_energy_gro_doublers.slot,
            second_location_id,
        );
        *second_doublers_ref = context.storage_read(second_doublers_slot);
    });

    assert_eq(origin_pop_growth, base_target_pop_growth);
    assert_eq(origin_doublers, 0);
    assert_eq(second_pop_growth, base_second_pop_growth * 2);
    assert_eq(second_doublers, 1);
}

#[test]
unconstrained fn test_spaceship_location_mapping_updates() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            MOVE_X_2,
            MOVE_Y_2,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    let home_location_id = expected_location_id(INIT_X, INIT_Y);
    let target_location_id = expected_location_id(MOVE_X_2, MOVE_Y_2);

    env.call_private(
        player,
        DarkForest::at(contract_address).give_space_ships(home_location_id)
    );

    let ship_id = expected_ship_id(home_location_id, ARTIFACT_TYPE_SHIP_MOTHERSHIP);

    let mut home_speed: u64 = 0;
    let home_speed_ref = &mut home_speed;
    env.public_context_at(contract_address, |context| {
        let home_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            home_location_id,
        );
        *home_speed_ref = context.storage_read(home_slot + 10);
    });

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            INIT_X,
            INIT_Y,
            MOVE_X_2,
            MOVE_Y_2,
            utils::WORLD_RADIUS,
            MOVE_DIST_MAX,
            0,
            0,
            ship_id,
            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );

    env.public_context_at(contract_address, |context| {
        let location_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().artifact_locations.slot,
            ship_id,
        );
        let stored_location = context.storage_read(location_slot);
        assert_eq(stored_location, 0);
    });

    let mut travel_time = (MOVE_DIST_MAX * 100) / home_speed;
    if travel_time == 0 {
        travel_time = 1;
    }
    let mut advance_blocks = travel_time - 1;
    assert(advance_blocks <= MAX_ADVANCE_BLOCKS);
    for i in 0..MAX_ADVANCE_BLOCKS {
        if (i as u64) < advance_blocks {
            env.call_private(
                player,
                DarkForest::at(contract_address).reveal_location(
                    (9000 + (i as u64)) as Field,
                    0,
                    utils::PLANETHASH_KEY,
                    utils::SPACETYPE_KEY,
                    utils::PERLIN_LENGTH_SCALE,
                    utils::PERLIN_MIRROR_X,
                    utils::PERLIN_MIRROR_Y,
                    utils::spacetype_config_hash(),
                    utils::MAX_LOCATION_ID,
                )
            );
        }
    }

    env.call_private(
        player,
        DarkForest::at(contract_address).resolve_arrival(1)
    );

    env.public_context_at(contract_address, |context| {
        let location_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().artifact_locations.slot,
            ship_id,
        );
        let stored_location = context.storage_read(location_slot);
        assert_eq(stored_location, target_location_id);
    });
}

#[test]
unconstrained fn test_activate_crescent_spaceship() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            MOVE_X_2,
            MOVE_Y_2,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    let home_location_id = expected_location_id(INIT_X, INIT_Y);
    let target_location_id = expected_location_id(MOVE_X_2, MOVE_Y_2);

    env.call_private(
        player,
        DarkForest::at(contract_address).give_space_ships(home_location_id)
    );

    let ship_id = expected_ship_id(home_location_id, ARTIFACT_TYPE_SHIP_CRESCENT);
    env.public_context_at(contract_address, |context| {
        let ship_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().spaceships.slot,
            ship_id,
        );
        let stored_ship_type = context.storage_read(ship_slot);
        assert_eq(stored_ship_type, ARTIFACT_TYPE_SHIP_CRESCENT);
    });

    let mut home_speed: u64 = 0;
    let home_speed_ref = &mut home_speed;
    env.public_context_at(contract_address, |context| {

        let home_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            home_location_id,
        );
        *home_speed_ref = context.storage_read(home_slot + 10);
    });

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            INIT_X,
            INIT_Y,
            MOVE_X_2,
            MOVE_Y_2,
            utils::WORLD_RADIUS,
            MOVE_DIST_MAX,
            0,
            0,
            ship_id,
            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );

    let mut travel_time = (MOVE_DIST_MAX * 100) / home_speed;
    if travel_time == 0 {
        travel_time = 1;
    }
    let mut advance_blocks = travel_time - 1;
    assert(advance_blocks <= MAX_ADVANCE_BLOCKS);
    for i in 0..MAX_ADVANCE_BLOCKS {
        if (i as u64) < advance_blocks {
            env.call_private(
                player,
                DarkForest::at(contract_address).reveal_location(
                    (9200 + (i as u64)) as Field,
                    0,
                    utils::PLANETHASH_KEY,
                    utils::SPACETYPE_KEY,
                    utils::PERLIN_LENGTH_SCALE,
                    utils::PERLIN_MIRROR_X,
                    utils::PERLIN_MIRROR_Y,
                    utils::spacetype_config_hash(),
                    utils::MAX_LOCATION_ID,
                )
            );
        }
    }

    env.call_private(
        player,
        DarkForest::at(contract_address).resolve_arrival(1)
    );

    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_owner(
            target_location_id,
            AztecAddress::zero(),
        )
    );
    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_type_and_level(
            target_location_id,
            PLANET_TYPE_PLANET,
            1,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).set_artifact_activation(
            target_location_id,
            ship_id,
            0,
            true,
        )
    );

    env.public_context_at(contract_address, |context| {
        let planet_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            target_location_id,
        );
        let stored_planet_type = context.storage_read(planet_slot + 14);
        assert_eq(stored_planet_type, PLANET_TYPE_SILVER_MINE);
    });
}

#[test(should_fail)]
unconstrained fn test_fail_activate_non_crescent_spaceship() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            MOVE_X_2,
            MOVE_Y_2,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    let home_location_id = expected_location_id(INIT_X, INIT_Y);
    let target_location_id = expected_location_id(MOVE_X_2, MOVE_Y_2);

    env.call_private(
        player,
        DarkForest::at(contract_address).give_space_ships(home_location_id)
    );

    let ship_id = expected_ship_id(home_location_id, ARTIFACT_TYPE_SHIP_MOTHERSHIP);

    let mut home_speed: u64 = 0;
    let home_speed_ref = &mut home_speed;
    env.public_context_at(contract_address, |context| {
        let home_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            home_location_id,
        );
        *home_speed_ref = context.storage_read(home_slot + 10);
    });

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            INIT_X,
            INIT_Y,
            MOVE_X_2,
            MOVE_Y_2,
            utils::WORLD_RADIUS,
            MOVE_DIST_MAX,
            0,
            0,
            ship_id,
            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );

    let mut travel_time = (MOVE_DIST_MAX * 100) / home_speed;
    if travel_time == 0 {
        travel_time = 1;
    }
    let mut advance_blocks = travel_time - 1;
    assert(advance_blocks <= MAX_ADVANCE_BLOCKS);
    for i in 0..MAX_ADVANCE_BLOCKS {
        if (i as u64) < advance_blocks {
            env.call_private(
                player,
                DarkForest::at(contract_address).reveal_location(
                    (9400 + (i as u64)) as Field,
                    0,
                    utils::PLANETHASH_KEY,
                    utils::SPACETYPE_KEY,
                    utils::PERLIN_LENGTH_SCALE,
                    utils::PERLIN_MIRROR_X,
                    utils::PERLIN_MIRROR_Y,
                    utils::spacetype_config_hash(),
                    utils::MAX_LOCATION_ID,
                )
            );
        }
    }

    env.call_private(
        player,
        DarkForest::at(contract_address).resolve_arrival(1)
    );

    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_owner(
            target_location_id,
            AztecAddress::zero(),
        )
    );
    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_type_and_level(
            target_location_id,
            PLANET_TYPE_PLANET,
            1,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).set_artifact_activation(
            target_location_id,
            ship_id,
            0,
            true,
        )
    );
}

#[test(should_fail)]
unconstrained fn test_fail_spaceship_move_nonzero_pop() {
    let (mut env, contract_address, _) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,

            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let home_location_id = expected_location_id(INIT_X, INIT_Y);
    env.call_private(
        player,
        DarkForest::at(contract_address).give_space_ships(home_location_id)
    );

    let ship_id = expected_ship_id(home_location_id, ARTIFACT_TYPE_SHIP_MOTHERSHIP);
    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            INIT_X,
            INIT_Y,
            MOVE_X_2,
            MOVE_Y_2,
            utils::WORLD_RADIUS,
            MOVE_DIST_MAX,
            1,
            0,
            ship_id,
            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );
}

#[test]
unconstrained fn test_artifact_voyage_moves_artifact() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            MOVE_X_2,
            MOVE_Y_2,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    let home_location_id = expected_location_id(INIT_X, INIT_Y);
    let target_location_id = expected_location_id(MOVE_X_2, MOVE_Y_2);

    let artifact_id: Field = 9101;
    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_create_artifact_on_planet(
            home_location_id,
            artifact_id,
            ARTIFACT_TYPE_MONOLITH,
            ARTIFACT_RARITY_COMMON,
            BIOME_OCEAN,
            contract_address,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            INIT_X,
            INIT_Y,
            MOVE_X_2,
            MOVE_Y_2,
            utils::WORLD_RADIUS,
            MOVE_DIST_MAX,
            MOVE_POP_MOVED,
            0,
            artifact_id,
            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );

    let mut home_speed: u64 = 0;
    let home_speed_ref = &mut home_speed;
    env.public_context_at(contract_address, |context| {
        let planet_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            home_location_id,
        );
        *home_speed_ref = context.storage_read(planet_slot + 10);
    });

    let mut travel_time = (MOVE_DIST_MAX * 100) / home_speed;
    if travel_time == 0 {
        travel_time = 1;
    }
    let mut advance_blocks = travel_time - 1;
    assert(advance_blocks <= MAX_ADVANCE_BLOCKS);
    for i in 0..MAX_ADVANCE_BLOCKS {
        if (i as u64) < advance_blocks {
            env.call_private(
                player,
                DarkForest::at(contract_address).reveal_location(
                    (6000 + (i as u64)) as Field,
                    0,
                    utils::PLANETHASH_KEY,
                    utils::SPACETYPE_KEY,
                    utils::PERLIN_LENGTH_SCALE,
                    utils::PERLIN_MIRROR_X,
                    utils::PERLIN_MIRROR_Y,
                    utils::spacetype_config_hash(),
                    utils::MAX_LOCATION_ID,
                )
            );
        }
    }

    env.call_private(
        player,
        DarkForest::at(contract_address).resolve_arrival(1)
    );

    env.public_context_at(contract_address, |context| {
        let location_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().artifact_locations.slot,
            artifact_id,
        );
        let stored_location = context.storage_read(location_slot);
        assert_eq(stored_location, target_location_id);

        let target_list_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_artifacts.slot,
            target_location_id,
        );
        let target_slot0 = context.storage_read(target_list_slot);
        assert_eq(target_slot0, artifact_id);

        let home_list_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_artifacts.slot,
            home_location_id,
        );
        let home_slot0 = context.storage_read(home_list_slot);
        assert(home_slot0 != artifact_id);
    });
}

#[test(should_fail)]
unconstrained fn test_fail_artifact_voyage_destination_full() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            MOVE_X_2,
            MOVE_Y_2,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    let home_location_id = expected_location_id(INIT_X, INIT_Y);
    let target_location_id = expected_location_id(MOVE_X_2, MOVE_Y_2);

    for i in 0..5 {
        let artifact_id: Field = (9200u64 + (i as u64)) as Field;
        env.call_private(
            admin,
            DarkForest::at(contract_address).admin_create_artifact_on_planet(
                target_location_id,
                artifact_id,
                ARTIFACT_TYPE_MONOLITH,
                ARTIFACT_RARITY_COMMON,
                BIOME_OCEAN,
                contract_address,
            )
        );
    }

    let moving_artifact_id: Field = 9301;
    env.call_private(
        admin,

        DarkForest::at(contract_address).admin_create_artifact_on_planet(
            home_location_id,
            moving_artifact_id,
            ARTIFACT_TYPE_MONOLITH,
            ARTIFACT_RARITY_COMMON,
            BIOME_OCEAN,
            contract_address,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            INIT_X,
            INIT_Y,
            MOVE_X_2,
            MOVE_Y_2,
            utils::WORLD_RADIUS,
            MOVE_DIST_MAX,
            MOVE_POP_MOVED,
            0,
            moving_artifact_id,
            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );
}

#[test]
unconstrained fn test_abandon_planet_success() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    let mut abandon_x: Field = 0;
    let mut abandon_y: Field = 0;
    let mut dest_x: Field = 0;
    let mut dest_y: Field = 0;
    let mut found = false;

    for dx in 0..(SEARCH_MAX_DIST_RUINS + 1) {
        for dy in 0..(SEARCH_MAX_DIST_RUINS + 1) {
            let is_home = (dx == 0) & (dy == 0);
            if (!found) & !is_home {
                let x = INIT_X + (dx as Field);
                let y = dy as Field;
                let perlin = expected_perlin(x, y);
                let location_id = expected_location_id(x, y);
                let space_type = expected_space_type(perlin);
                let level = expected_planet_level(location_id, space_type);
                let planet_type = expected_planet_type(location_id, space_type, level);
                if (level >= 6) & (planet_type == PLANET_TYPE_PLANET) {
                    abandon_x = x;
                    abandon_y = y;
                    dest_x = x + 1;
                    dest_y = y;
                    found = true;
                }
            }
        }
    }
    assert(found);

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            abandon_x,
            abandon_y,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            dest_x,
            dest_y,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    let abandon_location_id = expected_location_id(abandon_x, abandon_y);

    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_owner(
            abandon_location_id,
            player,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            abandon_x,
            abandon_y,
            dest_x,
            dest_y,
            utils::WORLD_RADIUS,
            MOVE_DIST_MAX,
            0,
            0,
            0,
            true,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );

    env.public_context_at(contract_address, |context| {
        let planet_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planets.slot,
            abandon_location_id,
        );
        let stored_owner = context.storage_read(planet_slot + 1);
        let space_junk_slot = derive_storage_slot_in_map(
            DarkForest::storage_layout().planet_space_junk.slot,
            abandon_location_id,
        );
        let stored_space_junk = context.storage_read(space_junk_slot);
        assert_eq(stored_owner, AztecAddress::zero());
        assert(stored_space_junk > 0);
    });
}

#[test(should_fail)]
unconstrained fn test_fail_abandon_with_incoming_arrival() {
    let (mut env, contract_address, admin) = utils::setup();
    let player = env.create_light_account();

    env.call_private(
        player,
        DarkForest::at(contract_address).init_player(
            INIT_X,
            INIT_Y,
            INIT_RADIUS,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
            utils::SPAWN_RIM_AREA,
            utils::INIT_PERLIN_MIN,
            utils::INIT_PERLIN_MAX,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            MOVE_X_2,
            MOVE_Y_2,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).reveal_location(
            CAPTURE_X_2,
            CAPTURE_Y_2,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
        )
    );

    let abandon_location_id = expected_location_id(MOVE_X_2, MOVE_Y_2);
    env.call_private(
        admin,
        DarkForest::at(contract_address).admin_set_planet_owner(
            abandon_location_id,
            player,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            INIT_X,
            INIT_Y,
            MOVE_X_2,
            MOVE_Y_2,
            utils::WORLD_RADIUS,
            MOVE_DIST_MAX,
            MOVE_POP_MOVED,
            0,
            0,
            false,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,

            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );

    env.call_private(
        player,
        DarkForest::at(contract_address).move(
            MOVE_X_2,
            MOVE_Y_2,
            CAPTURE_X_2,
            CAPTURE_Y_2,
            utils::WORLD_RADIUS,
            MOVE_DIST_MAX,
            0,
            0,
            0,
            true,
            utils::PLANETHASH_KEY,
            utils::SPACETYPE_KEY,
            utils::PERLIN_LENGTH_SCALE,
            utils::PERLIN_MIRROR_X,
            utils::PERLIN_MIRROR_Y,
            utils::spacetype_config_hash(),
            utils::MAX_LOCATION_ID,
            utils::WORLD_RADIUS,
        )
    );
}

===== FILE: apps/client/src/Backend/Aztec/AztecConnection.ts =====
Explanation: Wraps Aztec node/client access with polling and interface compatibility for the frontend.
import type { DiagnosticUpdater, EthAddress, GasPrices } from '@darkforest_eth/types';
import { monomitter, Monomitter } from '@darkforest_eth/events';
import { BigNumber } from 'ethers';
import type { Contract } from 'ethers';
import type { AztecNode } from '@aztec/stdlib/interfaces/client';
import type { ClientConfig } from './config';
import { CLIENT_CONFIG } from './config';
import { connectDarkForest, type ClientLogFn, type DarkForestClient } from './scripts/darkforest';

type ProviderLike = {
  getBlock: (blockNumber: number) => Promise<{ timestamp: number; hash?: string } | undefined>;
};

export class AztecConnection {
  private client: DarkForestClient;
  private nodeUrl: string;
  private blockNumber = 0;
  private polling?: ReturnType<typeof setInterval>;
  private diagnosticsUpdater?: DiagnosticUpdater;
  private gasPrices: GasPrices = { slow: 0, average: 0, fast: 0 };

  public readonly blockNumber$: Monomitter<number>;
  public readonly myBalance$: Monomitter<BigNumber>;
  public readonly rpcChanged$: Monomitter<string>;
  public readonly gasPrices$: Monomitter<GasPrices>;

  private constructor(client: DarkForestClient, nodeUrl: string) {
    this.client = client;
    this.nodeUrl = nodeUrl;
    this.blockNumber$ = monomitter(true);
    this.myBalance$ = monomitter(true);
    this.rpcChanged$ = monomitter(true);
    this.gasPrices$ = monomitter(true);
    this.rpcChanged$.publish(nodeUrl);
    this.myBalance$.publish(BigNumber.from(0));
    this.gasPrices$.publish(this.gasPrices);
    this.startPolling();
  }

  static async connect(config: ClientConfig = CLIENT_CONFIG, log?: ClientLogFn) {
    const client = await connectDarkForest(config, log);
    return new AztecConnection(client, config.nodeUrl);
  }

  getNode(): AztecNode {
    return this.client.node;
  }

  getClient(): DarkForestClient {
    return this.client;
  }

  getAddress(): EthAddress | undefined {
    return this.client.account.address.toString() as EthAddress;
  }

  getCurrentBlockNumber(): number {
    return this.blockNumber;
  }

  getProvider(): ProviderLike {
    return {
      getBlock: async (blockNumber: number) => {
        const block = await this.client.node.getBlock(blockNumber);
        if (!block) return undefined;
        const timestamp = Number(block.timestamp);
        let hash: string | undefined;
        try {
          hash = (await block.hash()).toString();
        } catch {
          hash = undefined;
        }
        return { timestamp, hash };
      },
    };
  }

  getMyBalance(): BigNumber | undefined {
    return BigNumber.from(0);
  }

  getAutoGasPrices(): GasPrices {
    return { ...this.gasPrices };
  }

  getRpcEndpoint(): string {
    return this.nodeUrl;
  }

  async setRpcUrl(_rpcUrl: string): Promise<void> {
    throw new Error('Switching RPC endpoints is not supported in the Aztec client.');
  }

  async setAccount(_skey: string): Promise<void> {
    throw new Error('Setting Ethereum accounts is not supported in the Aztec client.');
  }

  async loadContract<T extends Contract>(..._args: unknown[]): Promise<T> {
    throw new Error('Ethereum contracts are not supported in the Aztec client.');
  }

  async loadBalance(_address?: EthAddress): Promise<BigNumber> {
    return BigNumber.from(0);
  }

  setDiagnosticUpdater(diagnosticUpdater?: DiagnosticUpdater) {
    this.diagnosticsUpdater = diagnosticUpdater;
  }

  async signMessageObject(_payload?: unknown): Promise<never> {
    throw new Error('signMessageObject is not supported for Aztec accounts.');
  }

  async signMessage(): Promise<never> {
    throw new Error('signMessage is not supported for Aztec accounts.');
  }

  getPrivateKey(): never {
    throw new Error('getPrivateKey is not supported for Aztec accounts.');
  }

  async stop() {
    if (this.polling) clearInterval(this.polling);
    await this.client.stop?.();
  }

  private startPolling() {
    this.polling = setInterval(() => {
      this.refreshBlockNumber().catch(() => {
        // ignore polling errors; UI will retry on next tick
      });
    }, 2000);
  }

  private async refreshBlockNumber() {
    const next = Number(await this.client.node.getBlockNumber());
    if (next !== this.blockNumber) {
      this.blockNumber = next;
      this.blockNumber$.publish(next);
    }
  }
}

===== FILE: apps/client/src/Backend/Aztec/config.ts =====
Explanation: Loads environment configuration for Aztec client connections and perlin settings.
import type { PerlinConfig } from "./scripts/types";

const env = process.env;

const getEnv = (primary: string, fallback?: string) => {
    const direct = env[primary];
    if (direct !== undefined && direct !== "") return direct;
    const legacy = env[`VITE_${primary}`];
    if (legacy !== undefined && legacy !== "") return legacy;
    return fallback;
};

const toBool = (value: string | undefined, fallback: boolean) => {
    if (value === undefined) return fallback;
    return value === "true" || value === "1";
};

const toBigInt = (value: string | undefined, fallback: string) => {
    return BigInt(value ?? fallback);
};

export type ClientAccountConfig = {
    secret?: string;
    salt?: string;
    signingKey?: string;
    testAccountIndex?: number;
};

export type ClientConfig = {
    nodeUrl: string;
    darkforestAddress: string;
    nftAddress?: string;
    sponsoredFpcAddress?: string;
    perlin: PerlinConfig;
    account?: ClientAccountConfig;
    proverEnabled?: boolean;
    autoResolveArrivals?: boolean;
};

export const DEFAULT_PERLIN_CONFIG: PerlinConfig = {
    planethashKey: toBigInt(getEnv("PLANETHASH_KEY"), "42"),
    spacetypeKey: toBigInt(getEnv("SPACETYPE_KEY"), "43"),
    perlinLengthScale: toBigInt(getEnv("PERLIN_LENGTH_SCALE"), "1024"),
    perlinMirrorX: toBool(getEnv("PERLIN_MIRROR_X"), false),
    perlinMirrorY: toBool(getEnv("PERLIN_MIRROR_Y"), false),
};

export const DEFAULT_INIT = {
    x: getEnv("INIT_X", "990") ?? "990",
    y: getEnv("INIT_Y", "0") ?? "0",
    radius: getEnv("INIT_RADIUS", "1000") ?? "1000",
};

export const DEFAULT_REVEAL = {
    x: getEnv("REVEAL_X", "123") ?? "123",
    y: getEnv("REVEAL_Y", "456") ?? "456",
};

export const CLIENT_CONFIG: ClientConfig = {
    nodeUrl: getEnv("AZTEC_NODE_URL", "http://localhost:8080") ?? "http://localhost:8080",
    darkforestAddress: getEnv("DARKFOREST_ADDRESS", "") ?? "",
    nftAddress: getEnv("NFT_ADDRESS"),
    sponsoredFpcAddress: getEnv("SPONSORED_FPC_ADDRESS"),
    perlin: DEFAULT_PERLIN_CONFIG,
    account: {
        secret: getEnv("ACCOUNT_SECRET"),
        salt: getEnv("ACCOUNT_SALT"),
        signingKey: getEnv("ACCOUNT_SIGNING_KEY"),
        testAccountIndex: getEnv("ACCOUNT_INDEX")
            ? Number(getEnv("ACCOUNT_INDEX"))
            : undefined,
    },
    proverEnabled: toBool(getEnv("PROVER_ENABLED"), false),
    autoResolveArrivals: toBool(getEnv("DF_AUTO_RESOLVE_ARRIVALS"), true),
};

export const VERBOSE_LOGGING = toBool(getEnv("DF_VERBOSE_LOGS"), false);

// The local Aztec devnet ships with 3 pre-funded test accounts (indices 0-2).
export const MAX_TEST_ACCOUNTS = 3;

===== FILE: apps/client/src/Backend/Aztec/constants.ts =====
Explanation: Client-side constants mirroring on-chain planet/biome tuning values.
export const PLANET_DEFAULT_POP_CAP = [
  100000,
  400000,
  1600000,
  6000000,
  25000000,
  100000000,
  300000000,
  500000000,
  700000000,
  800000000,
];

export const PLANET_DEFAULT_POP_GROWTH = [417, 833, 1250, 1667, 2083, 2500, 2917, 3333, 3750, 4167];

export const PLANET_DEFAULT_RANGE = [99, 177, 315, 591, 1025, 1734, 2838, 4414, 6306, 8829];

export const PLANET_DEFAULT_SPEED = [75, 75, 75, 75, 75, 75, 75, 75, 75, 75];

export const PLANET_DEFAULT_DEFENSE = [400, 400, 300, 300, 300, 200, 200, 200, 200, 200];

export const PLANET_DEFAULT_SILVER_GROWTH = [0, 56, 167, 417, 833, 1667, 2778, 2778, 2778, 2778];

export const PLANET_DEFAULT_SILVER_CAP = [
  0,
  100000,
  500000,
  2500000,
  12000000,
  50000000,
  100000000,
  200000000,
  300000000,
  400000000,
];

export const PLANET_DEFAULT_BARBARIAN_PERCENT = [0, 1, 2, 3, 4, 5, 7, 10, 20, 25];

export const PLANET_LEVEL_THRESHOLDS = [
  16777216,
  4194292,
  1048561,
  262128,
  65520,
  16368,
  4080,
  1008,
  240,
  48,
];

export const PLANET_TYPE_WEIGHTS = [
  [
    [1, 0, 0, 0, 0],
    [13, 2, 0, 1, 0],
    [13, 2, 0, 1, 0],
    [13, 2, 0, 0, 1],
    [13, 2, 0, 0, 1],
    [13, 2, 0, 0, 1],
    [13, 2, 0, 0, 1],
    [13, 2, 0, 0, 1],
    [13, 2, 0, 0, 1],
    [13, 2, 0, 0, 1],
  ],
  [
    [1, 0, 0, 0, 0],
    [13, 2, 1, 0, 0],
    [12, 2, 1, 1, 0],
    [11, 2, 1, 1, 1],
    [12, 2, 1, 0, 1],
    [12, 2, 1, 0, 1],
    [12, 2, 1, 0, 1],
    [12, 2, 1, 0, 1],
    [12, 2, 1, 0, 1],
    [12, 2, 1, 0, 1],
  ],
  [
    [1, 0, 0, 0, 0],
    [10, 4, 2, 0, 0],
    [10, 4, 1, 1, 0],
    [8, 4, 1, 2, 1],
    [8, 4, 1, 2, 1],
    [8, 4, 1, 2, 1],
    [8, 4, 1, 2, 1],
    [8, 4, 1, 2, 1],
    [8, 4, 1, 2, 1],
    [8, 4, 1, 2, 1],
  ],
  [
    [1, 0, 0, 0, 0],
    [11, 4, 1, 0, 0],
    [11, 4, 1, 0, 0],
    [7, 4, 2, 2, 1],
    [7, 4, 2, 2, 1],
    [7, 4, 2, 2, 1],
    [7, 4, 2, 2, 1],
    [7, 4, 2, 2, 1],
    [7, 4, 2, 2, 1],
    [7, 4, 2, 2, 1],
  ],
] as const;

export const PLANET_LEVEL_JUNK = [20, 25, 30, 35, 40, 45, 50, 55, 60, 65];

export const ARTIFACT_POINT_VALUES = [0, 2000, 10000, 200000, 3000000, 20000000];

export const ROUND_END_REWARDS_BY_RANK = new Array(10).fill(0) as [
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number
];


===== FILE: apps/client/src/Backend/Aztec/typeAdapters.ts =====
Explanation: Maps Aztec on-chain state into Dark Forest client types and derived stats.
import { EMPTY_ADDRESS } from '@darkforest_eth/constants';
import {
  artifactIdFromDecStr,
  locationIdFromDecStr,
} from '@darkforest_eth/serde';
import type {
  Artifact,
  ArtifactId,
  ArtifactRarity,
  ArtifactType,
  Biome,
  EthAddress,
  Planet,
  PlanetBonus,
  PlanetType,
  Player,
  RevealedCoords as DFRevealedCoords,
  SpaceType,
  Upgrade,
  UpgradeBranches,
  VoyageId,
  QueuedArrival,
  ArrivalType,
} from '@darkforest_eth/types';
import type { AztecAddress } from '@aztec/aztec.js/addresses';
import type {
  ArtifactState,
  ArrivalState,
  PlanetArtifactState,
  PlanetArtifactsState,
  PlanetState,
  PlayerState,
  RevealedCoords,
} from './scripts/types';
import { fieldToSignedInt, multiScalePerlin } from './scripts/hashing';
import type { OnChainConfig } from './scripts/types';
import type { ContractConstants } from '../../_types/darkforest/api/ContractsAPITypes';

const ZERO_ADDRESS_REGEX = /^0x0+$/;
const toNumber = (value: bigint | number) => Number(value);

export const toEthAddress = (address: AztecAddress | string): EthAddress => {
  const raw = typeof address === 'string' ? address.toLowerCase() : address.toString().toLowerCase();
  if (ZERO_ADDRESS_REGEX.test(raw)) {
    return EMPTY_ADDRESS as EthAddress;
  }
  return raw as EthAddress;
};

export const toLocationId = (value: bigint): string => locationIdFromDecStr(value.toString());
export const toArtifactId = (value: bigint): ArtifactId => artifactIdFromDecStr(value.toString());

export const buildDefaultUpgrade = (): Upgrade => ({
  energyCapMultiplier: 100,
  energyGroMultiplier: 100,
  rangeMultiplier: 100,
  speedMultiplier: 100,
  defMultiplier: 100,
});

export const buildUpgrades = (): UpgradeBranches => {
  const defenseUpgrade: Upgrade = {
    energyCapMultiplier: 120,
    energyGroMultiplier: 120,
    rangeMultiplier: 100,
    speedMultiplier: 100,
    defMultiplier: 120,
  };
  const rangeUpgrade: Upgrade = {
    energyCapMultiplier: 120,
    energyGroMultiplier: 120,
    rangeMultiplier: 125,
    speedMultiplier: 100,
    defMultiplier: 100,
  };
  const speedUpgrade: Upgrade = {
    energyCapMultiplier: 120,
    energyGroMultiplier: 120,
    rangeMultiplier: 100,
    speedMultiplier: 175,
    defMultiplier: 100,
  };

  const toLevels = (upgrade: Upgrade): [Upgrade, Upgrade, Upgrade, Upgrade] => [
    { ...upgrade },
    { ...upgrade },
    { ...upgrade },
    { ...upgrade },
  ];

  return [toLevels(defenseUpgrade), toLevels(rangeUpgrade), toLevels(speedUpgrade)];
};

export const buildArtifactUpgrade = (artifactType: number, rarity: number): Upgrade => {
  const idx = Math.max(0, Math.min(rarity, 5));
  if (artifactType === 6) {
    const def = [100, 150, 200, 300, 450, 650];
    return {
      energyCapMultiplier: 100,
      energyGroMultiplier: 100,
      rangeMultiplier: 20,
      speedMultiplier: 20,
      defMultiplier: def[idx],
    };
  }
  if (artifactType === 7) {
    const def = [100, 50, 40, 30, 20, 10];
    return {
      energyCapMultiplier: 100,
      energyGroMultiplier: 100,
      rangeMultiplier: 100,
      speedMultiplier: 100,
      defMultiplier: def[idx],
    };
  }
  return buildDefaultUpgrade();
};

export const buildTimeDelayedUpgrade = (artifactType: number, rarity: number): Upgrade => {
  if (artifactType !== 7) {
    return buildDefaultUpgrade();
  }
  const idx = Math.max(0, Math.min(rarity, 5));
  const range = [100, 200, 200, 200, 200, 200];
  const speed = [100, 500, 1000, 1500, 2000, 2500];
  return {
    energyCapMultiplier: 100,
    energyGroMultiplier: 100,
    rangeMultiplier: range[idx],
    speedMultiplier: speed[idx],
    defMultiplier: 100,
  };
};

export const mapRevealedCoords = (revealed: RevealedCoords): DFRevealedCoords | undefined => {
  if (!revealed || revealed.locationId === 0n) return undefined;
  return {
    x: toNumber(fieldToSignedInt(revealed.x)),
    y: toNumber(fieldToSignedInt(revealed.y)),
    hash: toLocationId(revealed.locationId),
    revealer: toEthAddress(revealed.revealer),
  };
};

export const mapPlayer = (
  address: AztecAddress,
  state: PlayerState,
  claimedShips: bigint,
  spaceJunk: bigint,
  spaceJunkLimit: bigint,
  lastRevealTimestamp: number
): Player => ({
  address: toEthAddress(address),
  homePlanetId: toLocationId(state.homePlanet),
  initTimestamp: 0,
  lastRevealTimestamp,
  lastClaimTimestamp: 0,
  score: 0,
  spaceJunk: toNumber(spaceJunk),
  spaceJunkLimit: toNumber(spaceJunkLimit),
  claimedShips: claimedShips === 1n,
});

export const mapPlanet = async ({
  locationId,
  planetState,
  artifactState,
  artifacts,
  revealed,
  destroyed,
  spaceJunk,
  lastUpdatedTimestamp,
  contractConstants,
  onChainConfig,
}: {
  locationId: bigint;
  planetState: PlanetState;
  artifactState: PlanetArtifactState;
  artifacts: PlanetArtifactsState;
  revealed?: DFRevealedCoords;
  destroyed: boolean;
  spaceJunk: bigint;
  lastUpdatedTimestamp: number;
  contractConstants: ContractConstants;
  onChainConfig: OnChainConfig;
}): Promise<Planet> => {
  const bonus: PlanetBonus = [false, false, false, false, false, false];
  const upgradeState: [number, number, number] = [
    planetState.upgradeState0,
    planetState.upgradeState1,
    planetState.upgradeState2,
  ];

  const planet: Planet = {
    locationId: toLocationId(locationId),
    perlin: toNumber(planetState.perlin),
    spaceType: planetState.spaceType as SpaceType,
    owner: toEthAddress(planetState.owner),
    hatLevel: 0,
    planetLevel: planetState.planetLevel as number,
    planetType: planetState.planetType as PlanetType,
    isHomePlanet: planetState.isHomePlanet,
    energyCap: toNumber(planetState.populationCap),
    energyGrowth: toNumber(planetState.populationGrowth),
    silverCap: toNumber(planetState.silverCap),
    silverGrowth: toNumber(planetState.silverGrowth),
    range: toNumber(planetState.range),
    defense: toNumber(planetState.defense),
    speed: toNumber(planetState.speed),
    energy: toNumber(planetState.population),
    silver: toNumber(planetState.silver),
    spaceJunk: toNumber(spaceJunk),
    lastUpdated: lastUpdatedTimestamp,
    upgradeState,
    hasTriedFindingArtifact: artifactState.hasTriedFindingArtifact,
    heldArtifactIds: artifacts.ids.filter((id) => id !== 0n).map(toArtifactId),
    destroyed,
    prospectedBlockNumber: artifactState.prospectedBlockNumber || undefined,
    localPhotoidUpgrade: undefined,
    transactions: undefined,
    unconfirmedAddEmoji: false,
    unconfirmedClearEmoji: false,
    loadingServerState: false,
    needsServerRefresh: false,
    lastLoadedServerState: undefined,
    silverSpent: 0,
    isInContract: planetState.isInitialized,
    syncedWithContract: true,
    coordsRevealed: !!revealed,
    revealer: revealed?.revealer,
    claimer: undefined,
    messages: [],
    bonus,
    pausers: 0,
    invader: EMPTY_ADDRESS as EthAddress,
    capturer: EMPTY_ADDRESS as EthAddress,
    invadeStartBlock: undefined,
  };

  if (revealed) {
    const biomebase = multiScalePerlin(
      BigInt(revealed.x),
      BigInt(revealed.y),
      onChainConfig.biomebaseKey,
      onChainConfig.perlinLengthScale,
      onChainConfig.perlinMirrorX,
      onChainConfig.perlinMirrorY
    );
    const biomebaseNumber = toNumber(biomebase);
    (planet as any).location = {

      coords: { x: revealed.x, y: revealed.y },
      hash: revealed.hash,
      perlin: planet.perlin,
      biomebase: biomebaseNumber,
    };
    (planet as any).biome = (() => {
      if (planet.spaceType === 3) return 10 as Biome;
      let biome = 3 * planet.spaceType;
      if (biomebaseNumber < contractConstants.BIOME_THRESHOLD_1) biome += 1;
      else if (biomebaseNumber < contractConstants.BIOME_THRESHOLD_2) biome += 2;
      else biome += 3;
      return biome as Biome;
    })();
  }

  return planet;
};

export const mapArtifact = async ({
  artifactState,
  locationId,
  owner,
  lastActivatedTimestamp,
  lastDeactivatedTimestamp,
  contractAddress,
  burnedLocationId,
}: {
  artifactState: ArtifactState;
  locationId: bigint;
  owner?: AztecAddress;
  lastActivatedTimestamp: number;
  lastDeactivatedTimestamp: number;
  contractAddress: AztecAddress;
  burnedLocationId: bigint;
}): Promise<Artifact> => {
  const artifactId = toArtifactId(artifactState.id);
  const isBurned = artifactState.burned || (burnedLocationId !== 0n && locationId === burnedLocationId);
  const onPlanetId =
    isBurned || locationId === 0n ? undefined : toLocationId(locationId);
  const wormholeTo =
    artifactState.wormholeTo === 0n ? undefined : toLocationId(artifactState.wormholeTo);
  const currentOwner = isBurned
    ? (EMPTY_ADDRESS as EthAddress)
    : owner
      ? toEthAddress(owner)
      : toEthAddress(contractAddress);

  return {
    isInititalized: artifactState.isInitialized,
    id: artifactId,
    planetDiscoveredOn: toLocationId(artifactState.planetDiscoveredOn),
    rarity: artifactState.rarity as ArtifactRarity,
    planetBiome: artifactState.planetBiome as Biome,
    mintedAtTimestamp: 0,
    discoverer: toEthAddress(artifactState.discoverer),
    artifactType: artifactState.artifactType as ArtifactType,
    activations: artifactState.activations,
    lastActivated: lastActivatedTimestamp,
    lastDeactivated: lastDeactivatedTimestamp,
    controller: currentOwner,
    upgrade: buildArtifactUpgrade(artifactState.artifactType, artifactState.rarity),
    timeDelayedUpgrade: buildTimeDelayedUpgrade(artifactState.artifactType, artifactState.rarity),
    currentOwner,
    wormholeTo,
    onPlanetId,
    onVoyageId: undefined,
    transactions: undefined,
  };
};

export const mapArrival = async ({
  arrivalId,
  arrivalState,
  departureTimestamp,
  arrivalTimestamp,
}: {
  arrivalId: bigint;
  arrivalState: ArrivalState;
  departureTimestamp: number;
  arrivalTimestamp: number;
}): Promise<QueuedArrival> => {
  return {
    eventId: arrivalId.toString() as VoyageId,
    player: toEthAddress(arrivalState.player),
    fromPlanet: toLocationId(arrivalState.fromPlanet),
    toPlanet: toLocationId(arrivalState.toPlanet),
    energyArriving: toNumber(arrivalState.popArriving),
    silverMoved: toNumber(arrivalState.silverMoved),
    artifactId:
      arrivalState.carriedArtifactId === 0n
        ? undefined
        : toArtifactId(arrivalState.carriedArtifactId),
    departureTime: departureTimestamp,
    arrivalTime: arrivalTimestamp,
    distance: toNumber(arrivalState.distance),
    arrivalType: arrivalState.arrivalType as ArrivalType,
  };
};

<<BUNDLE_CONTENT>>
